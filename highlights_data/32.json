{
    "asset_id": "28AEDF62F12B289C88BD6659BD6E50CC",
    "title": "Designing Data-Intensive Applications",
    "author": "Kleppmann, Martin",
    "highlights": [
        {
            "id": 799,
            "is_deleted": false,
            "representative_text": "But what if many-to-many relationships are very common in your data? The relational model can handle\nsimple cases of many-to-many relationships, but as the connections within your data become more\ncomplex, it becomes more natural to start modeling your data as a graph.\n\n\n\n",
            "selected_text": "But what if many-to-many relationships are very common in your data? The relational model can handle\nsimple cases of many-to-many relationships, but as the connections within your data become more\ncomplex, it becomes more natural to start modeling your data as a graph.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 801,
            "is_deleted": false,
            "representative_text": "Scalability is the term we use to describe a system\u2019s ability to cope with increased load. ",
            "selected_text": "Scalability is the term we use to describe a system\u2019s ability to cope with increased load",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 802,
            "is_deleted": false,
            "representative_text": "A need for greater scalability than relational databases can easily achieve, including very large\ndatasets or very high write throughput\n\n\n",
            "selected_text": "greater scalability than relational databases",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 803,
            "is_deleted": false,
            "representative_text": "There are plenty of well-known tree data structures that you can use, such\nas red-black trees or AVL trees [2]. With\nthese data structures, you can insert keys in any order and read them back in sorted order.\n\n",
            "selected_text": "There are plenty of well-known tree data structures that you can use, such\nas red-black trees or AVL trees [2]. With\nthese data structures, you can insert keys in any order and read them back in sorted order.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 804,
            "is_deleted": false,
            "representative_text": "While distributing stateless services across multiple machines is fairly straightforward, taking\nstateful data systems from a single node to a distributed setup can introduce a lot of additional\ncomplexity. For this reason, common wisdom until recently was to keep your database on a single\nnode (scale up) until scaling cost or high-availability requirements forced you to make it\ndistributed.\n\n",
            "selected_text": "While distributing stateless services across multiple machines is fairly straightforward, taking\nstateful data systems from a single node to a distributed setup can introduce a lot of additional\ncomplexity. For this reason, common wisdom until recently was to keep your database on a single\nnode (scale up) until scaling cost or high-availability requirements forced you to make it\ndistributed",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 805,
            "is_deleted": false,
            "representative_text": "A data warehouse, by contrast, is a separate database that analysts can query to their hearts\u2019\ncontent, without affecting OLTP operations\n[48].\nThe data warehouse contains a read-only copy of the data in all the various OLTP systems in the\ncompany. Data is extracted from OLTP databases (using either a periodic data dump or a continuous\nstream of updates), transformed into an analysis-friendly schema, cleaned up, and then loaded into\nthe data warehouse. This process of getting data into the warehouse is known as\nExtract\u2013Transform\u2013Load (ETL) and is illustrated in Figure\u00a03-8.\n\n\n",
            "selected_text": "A data warehouse, by contrast, is a separate database that analysts can query to their hearts\u2019\ncontent, without affecting OLTP operations\n[48].\nThe data warehouse contains a read-only copy of the data in all the various OLTP systems in the\ncompany. Data is extracted from OLTP databases (using either a periodic data dump or a continuous\nstream of updates), transformed into an analysis-friendly schema, cleaned up, and then loaded into\nthe data warehouse. This process of getting data into the warehouse is known as\nExtract\u2013Transform\u2013Load (ETL",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 806,
            "is_deleted": false,
            "representative_text": "In a web browser, using declarative CSS styling is much better than manipulating styles imperatively in\nJavaScript. Similarly, in databases, declarative query languages like SQL turned out to be much\nbetter than imperative query APIs.vi\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "In a web browser, using declarative CSS styling is much better than manipulating styles imperatively in\nJavaScript. Similarly, in databases, declarative query languages like SQL turned out to be much\nbetter than imperative query APIs",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 807,
            "is_deleted": false,
            "representative_text": "Document databases reverted back to the hierarchical model in one aspect: storing nested records\n(one-to-many relationships, like positions, education, and contact_info in\nFigure\u00a02-1) within their parent record rather than in a separate table.\n\n\n",
            "selected_text": "Document databases reverted back to the hierarchical model in one aspect: storing nested records",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 808,
            "is_deleted": false,
            "representative_text": "Table 3-1. Comparing characteristics of transaction processing versus analytic systems\n\n\n",
            "selected_text": "Table 3-1. Comparing characteristics of transaction processing versus analytic systems",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 809,
            "is_deleted": false,
            "representative_text": "The document model has limitations: for example, you cannot refer directly to a nested item\nwithin a document, but instead you need to say something like \u201cthe second item in the list of\npositions for user 251\u201d (much like an access path in the hierarchical model). ",
            "selected_text": "you cannot refer directly to a nested item",
            "color": "yellow",
            "note": "Cannot directly extra position of an employee. Need to go through the hierarchy until u reach the position node, so to speak ",
            "chapter": null
        },
        {
            "id": 810,
            "is_deleted": false,
            "representative_text": "Evolvability\n\n",
            "selected_text": "Evolvability",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 811,
            "is_deleted": false,
            "representative_text": "In order to make the database resilient to crashes, it is common for B-tree implementations to\ninclude an additional data structure on disk: a write-ahead log (WAL, also known as a redo log).\nThis is an append-only file to which every B-tree modification must be written before it can be\napplied to the pages of the tree itself. ",
            "selected_text": "B-tree implementations to\ninclude an additional data structure on disk: a write-ahead log (WAL, also known as a redo log).\nThis is an append-only file to which every B-tree modification must be written before it can be\napplied to the pages of the tree itself",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 812,
            "is_deleted": false,
            "representative_text": "Analyzing whether people are more inclined to buy fresh fruit or candy, depending on the day of the week\n\n",
            "selected_text": "Analyzing whether people are more inclined to buy fresh fruit or candy, depending on the day of the week",
            "color": "yellow",
            "note": "Example analytics query",
            "chapter": null
        },
        {
            "id": 813,
            "is_deleted": false,
            "representative_text": "Simplicity\n\n",
            "selected_text": "Simplicity",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 814,
            "is_deleted": false,
            "representative_text": "If your application has mostly one-to-many relationships (tree-structured\ndata) or no relationships between records, the document model is appropriate.\n\n\n",
            "selected_text": "If your application has mostly one-to-many relationships (tree-structured\ndata) or no relationships between records, the document model is appropriate.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 815,
            "is_deleted": false,
            "representative_text": "There is also overhead from having\nto write an entire page at a time, even if only a few bytes in that page changed. ",
            "selected_text": "There is also overhead from having\nto write an entire page at a time, even if only a few bytes in that page changed",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 817,
            "is_deleted": false,
            "representative_text": "Frustration with the restrictiveness of relational schemas, and a desire for a more dynamic and\nexpressive data model [5]\n\n\n\n\n",
            "selected_text": "more dynamic and\nexpressive data model ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 818,
            "is_deleted": false,
            "representative_text": "They are usually reluctant to let business analysts\nrun ad hoc analytic queries on an OLTP database, since those queries are often expensive, scanning\nlarge parts of the dataset, which can harm the performance of concurrently executing transactions.\n\n\n\n\n",
            "selected_text": "They are usually reluctant to let business analysts\nrun ad hoc analytic queries on an OLTP database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 819,
            "is_deleted": false,
            "representative_text": "Even in \u201cnoncritical\u201d applications we have a responsibility to our users. ",
            "selected_text": "Even in \u201cnoncritical\u201d applications we have a responsibility to our users",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 820,
            "is_deleted": false,
            "representative_text": "A compromise between a clustered index (storing all row data within the index) and a nonclustered\nindex (storing only references to the data within the index) is known as a covering index or\nindex with included columns, which stores some of a table\u2019s columns within the index\n[33].\n",
            "selected_text": "A compromise between a clustered index (storing all row data within the index) and a nonclustered\nindex (storing only references to the data within the index",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 821,
            "is_deleted": false,
            "representative_text": "Historically, data started out being represented as one big tree (the hierarchical model), but that\nwasn\u2019t good for representing many-to-many relationships, so the relational model was invented to\nsolve that problem. More recently, developers found that some applications don\u2019t fit well in the\nrelational model either. New nonrelational \u201cNoSQL\u201d datastores have diverged in two main\ndirections:\n\n\nDocument databases target use cases where data comes in self-contained documents and\nrelationships between one document and another are rare.\n\n\nGraph databases go in the opposite direction, targeting use cases where anything is potentially\nrelated to everything.\n\n\n\n\n",
            "selected_text": "Historically, data started out being represented as one big tree (the hierarchical model), but that\nwasn\u2019t good for representing many-to-many relationships, so the relational model was invented to\nsolve that problem. More recently, developers found that some applications don\u2019t fit well in the\nrelational model either. New nonrelational \u201cNoSQL\u201d datastores have diverged in two main\ndirections:\n\n\nDocument databases target use cases where data comes in self-contained documents and\nrelationships between one document and another are rare.\n\n\nGraph databases go in the opposite direction, targeting use cases where anything is potentially\nrelated to everything.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 822,
            "is_deleted": false,
            "representative_text": "Imperative code is very hard to parallelize across multiple cores and multiple machines, because it\nspecifies instructions that must be performed in a particular order. Declarative languages have a\nbetter chance of getting faster in parallel execution because they specify only the pattern of the\nresults, not the algorithm that is used to determine the results. The database is free to use a\nparallel implementation of the query language, if appropriate\n[32].\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "Imperative code is very hard to parallelize across multiple cores and multiple machines, because it\nspecifies instructions that must be performed in a particular order. Declarative languages have a\nbetter chance of getting faster in parallel execution because they specify only the pattern of the\nresults, not the algorithm that is used to determine the results. The database is free to use a\nparallel implementation of the query language, if appropriate",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 824,
            "is_deleted": false,
            "representative_text": "Range queries are not efficient. ",
            "selected_text": "Range queries are not efficient",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 825,
            "is_deleted": false,
            "representative_text": "Joins can be emulated in\napplication code by making multiple requests to the database, but that also moves complexity into\nthe application and is usually slower than a join performed by specialized code inside the\ndatabase. ",
            "selected_text": "Joins can be emulated in\napplication code by making multiple requests to the database, but that also moves complexity into\nthe application and is usually slower than a join performed by specialized code inside the\ndatabase",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 826,
            "is_deleted": false,
            "representative_text": "The things that can go wrong are called faults, and systems that anticipate faults and can cope\nwith them are called fault-tolerant or resilient. ",
            "selected_text": "The things that can go wrong are called faults, and systems that anticipate faults and can cope\nwith them are called fault-tolerant or resilient",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 827,
            "is_deleted": false,
            "representative_text": "Making a system simpler does not necessarily mean reducing its functionality; it can also mean\nremoving accidental complexity. Moseley and Marks\n[32] define complexity as accidental if\nit is not inherent in the problem that the software solves (as seen by the users) but arises only\nfrom the implementation.\n\n\n",
            "selected_text": "Making a system simpler does not necessarily mean reducing its functionality; it can also mean\nremoving accidental complexity. Moseley and Marks\n[32] define complexity as accidental if\nit is not inherent in the problem that the software solves (as seen by the users) but arises only\nfrom the implementation",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 830,
            "is_deleted": false,
            "representative_text": "A downside of log-structured storage is that the compaction process can sometimes interfere with the\nperformance of ongoing reads and writes. ",
            "selected_text": "downside of log-structured storage is that the compaction process can sometimes interfere with the\nperformance of ongoing reads and writes.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 831,
            "is_deleted": false,
            "representative_text": "data is organized into relations (called tables in SQL), where each relation is an unordered collection\nof tuples (rows in SQL).\n\n\n",
            "selected_text": "data is organized into relations (called tables in SQL), where each relation is an unordered collection\nof tuples (rows in SQL).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 832,
            "is_deleted": false,
            "representative_text": "In order to figure out how bad your outliers are, you can look at higher percentiles: the 95th,\n99th, and 99.9th percentiles are common (abbreviated p95, p99, and p999). They are the\nresponse time thresholds at which 95%, 99%, or 99.9% of requests are faster than that particular\nthreshold. For example, if the 95th percentile response time is 1.5 seconds, that means 95 out of\n100 requests take less than 1.5 seconds, and 5 out of 100 requests take 1.5 seconds or more. This is\nillustrated in Figure\u00a01-4.\n\n\n\n",
            "selected_text": "In order to figure out how bad your outliers are, you can look at higher percentiles: the 95th,\n99th, and 99.9th percentiles are common (abbreviated p95, p99, and p999). They are the\nresponse time thresholds at which 95%, 99%, or 99.9% of requests are faster than that particular\nthreshold. For example, if the 95th percentile response time is 1.5 seconds, that means 95 out of\n100 requests take less than 1.5 seconds, and 5 out of 100 requests take 1.5 seconds or more. This is\nillustrated in Figure\u00a01-4.\n\n\n\n",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 833,
            "is_deleted": false,
            "representative_text": "LSM-trees are typically faster for writes, whereas B-trees are thought to be faster for reads\n[23].\n",
            "selected_text": "LSM-trees are typically faster for writes, whereas B-trees are thought to be faster for reads\n",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 834,
            "is_deleted": false,
            "representative_text": "This works better because the average\nrate of published tweets is almost two orders of magnitude lower than the rate of home timeline\nreads, and so in this case it\u2019s preferable to do more work at write time and less at read time.\n\n",
            "selected_text": "This works better because the average\nrate of published tweets is almost two orders of magnitude lower than the rate of home timeline\nreads, and so in this case it\u2019s preferable to do more work at write time and less at read time.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 835,
            "is_deleted": false,
            "representative_text": "The data model of a data warehouse is most commonly relational, because SQL is generally a good fit\nfor analytic queries. ",
            "selected_text": "The data model of a data warehouse is most commonly relational, because SQL is generally a good fit\nfor analytic queries",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 837,
            "is_deleted": false,
            "representative_text": "The\ndatabase typically needs to load the entire document, even if you access only a small portion of it,\nwhich can be wasteful on large documents. ",
            "selected_text": "The\ndatabase typically needs to load the entire document, even if you access only a small portion of it,\nwhich can be wasteful on large documents",
            "color": "yellow",
            "note": "Demerits of doc model",
            "chapter": null
        },
        {
            "id": 838,
            "is_deleted": false,
            "representative_text": "duplicating data when multiple secondary indexes are present: each index just references a location\nin the heap file, and the actual data is kept in one place.\n\n",
            "selected_text": "each index just references a location\nin the heap file, and the actual data is kept in one place.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 839,
            "is_deleted": false,
            "representative_text": "cost (e.g., when developing a prototype product for an unproven market) or operational cost (e.g., for\na service with a very narrow profit margin)\u2014but we should be very conscious of when we are\ncutting corners.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "when developing a prototype product for an unproven market",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 840,
            "is_deleted": false,
            "representative_text": "The situation is more complicated if the new value is larger, as it probably needs to be moved to a\nnew location in the heap where there is enough space. In that case, either all indexes need to be\nupdated to point at the new heap location of the record, or a forwarding pointer is left behind in\nthe old heap location [5].\n\n\n\n\n\n",
            "selected_text": "The situation is more complicated if the new value is larger, as it probably needs to be moved to a\nnew location in the heap where there is enough space. In that case, either all indexes need to be\nupdated to point at the new heap location of the record, or a forwarding pointer is left behind in\nthe old heap location",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 841,
            "is_deleted": false,
            "representative_text": "This makes the median a good metric if you want to know how long users typically have to wait: half\nof user requests are served in less than the median response time, and the other half take longer\nthan the median. ",
            "selected_text": "This makes the median a good metric if you want to know how long users typically have to wait: half\nof user requests are served in less than the median response time, and the other half take longer\nthan the median",
            "color": "yellow",
            "note": "P50",
            "chapter": null
        },
        {
            "id": 842,
            "is_deleted": false,
            "representative_text": "The final twist of the Twitter anecdote: now that approach 2 is robustly implemented, Twitter is\nmoving to a hybrid of both approaches. Most users\u2019 tweets continue to be fanned out to home\ntimelines at the time when they are posted, but a small number of users with a very large number of\nfollowers (i.e., celebrities) are excepted from this fan-out. ",
            "selected_text": "The final twist of the Twitter anecdote: now that approach 2 is robustly implemented, Twitter is\nmoving to a hybrid of both approaches. Most users\u2019 tweets continue to be fanned out to home\ntimelines at the time when they are posted, but a small number of users with a very large number of\nfollowers (i.e., celebrities) are excepted from this fan-out",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 843,
            "is_deleted": false,
            "representative_text": "such as LSM-trees, which only append to files (and eventually delete obsolete files) but never\nmodify files in place.\n\n",
            "selected_text": "LSM-trees, which only append to files (and eventually delete obsolete files)",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 844,
            "is_deleted": false,
            "representative_text": "But in cases where all records are expected to have the same\nstructure, schemas are a useful mechanism for documenting and enforcing that structure. ",
            "selected_text": "But in cases where all records are expected to have the same\nstructure, schemas are a useful mechanism for documenting and enforcing that structure",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 845,
            "is_deleted": false,
            "representative_text": "the data usually assumes some kind of structure\u2014i.e., there is an implicit schema, but it is not\nenforced by the database [20]. ",
            "selected_text": "there is an implicit schema, but it is not\nenforced by the database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 846,
            "is_deleted": false,
            "representative_text": "The main arguments in favor of the document data model are schema flexibility, better performance\ndue to locality, and that for some applications it is closer to the data structures used by the\napplication. ",
            "selected_text": "The main arguments in favor of the document data model are schema flexibility, better performance\ndue to locality, and that for some applications it is closer to the data structures used by the\napplication",
            "color": "yellow",
            "note": "But no querying by filtering the nested structure ",
            "chapter": null
        },
        {
            "id": 847,
            "is_deleted": false,
            "representative_text": "Compaction\nmeans throwing away duplicate keys in the log, and keeping only the most recent update for each key.\n\n\n",
            "selected_text": "Compaction\nmeans throwing away duplicate keys in the log, and keeping only the most recent update for each key.\n\n\n",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 848,
            "is_deleted": false,
            "representative_text": "Usually it is better to use percentiles. If you take your list of response times and sort it from\nfastest to slowest, then the median is the halfway point: for example, if your median response\ntime is 200\u00a0ms, that means half your requests return in less than 200\u00a0ms, and half your\nrequests take longer than that.\n\n",
            "selected_text": "Usually it is better to use percentiles. If you take your list of response times and sort it from\nfastest to slowest, then the median is the halfway point",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 850,
            "is_deleted": false,
            "representative_text": "sparse: one key for every few kilobytes of segment file is sufficient, because a few kilobytes can\nbe scanned very quickly.i\n\n\n",
            "selected_text": "one key for every few kilobytes of segment file is sufficient",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 851,
            "is_deleted": false,
            "representative_text": "Any kind of index usually slows down writes, because the index also needs\nto be updated every time data is written.\n\n",
            "selected_text": "Any kind of index usually slows down writes, because the index also needs\nto be updated every time data is written.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 852,
            "is_deleted": false,
            "representative_text": "In an early-stage startup or an unproven product it\u2019s usually more important to\nbe able to iterate quickly on product features than it is to scale to some hypothetical future\nload.\n\n",
            "selected_text": "In an early-stage startup or an unproven product it\u2019s usually more important to\nbe able to iterate quickly on product features than it is to scale to some hypothetical future\nload.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 853,
            "is_deleted": false,
            "representative_text": "A software\nproject mired in complexity is sometimes described as a big ball of mud\n[30].\n\n",
            "selected_text": "A software\nproject mired in complexity is sometimes described as a big ball of mud\n[30].",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 854,
            "is_deleted": false,
            "representative_text": "bandwidth can be used for the initial write, but the bigger the database gets, the more disk\nbandwidth is required for compaction.\n\n",
            "selected_text": "but the bigger the database gets, the more disk\nbandwidth is required for compaction.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 855,
            "is_deleted": false,
            "representative_text": "MapReduce is a programming model for processing large amounts of data in bulk across many\nmachines, popularized by Google\n[33]. ",
            "selected_text": "MapReduce is a programming model for processing large amounts of data in bulk across many\nmachines",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 856,
            "is_deleted": false,
            "representative_text": "When the relational model was introduced, it included a new way of querying data: SQL is a\ndeclarative query language, whereas IMS and CODASYL queried the database using imperative code.\n",
            "selected_text": "SQL is a\ndeclarative query language",
            "color": "yellow",
            "note": "U tell it what u want.. not how to",
            "chapter": null
        },
        {
            "id": 857,
            "is_deleted": false,
            "representative_text": "It is based on the map (also known as collect) and reduce (also\nknown as fold or inject) functions that exist in many functional programming languages.\n\n\n",
            "selected_text": "map (also known as collect) and reduce (also\nknown as fold or inject",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 858,
            "is_deleted": false,
            "representative_text": "Operability\n\n",
            "selected_text": "Operability",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 860,
            "is_deleted": false,
            "representative_text": "Some in-memory key-value stores, such as Memcached, are intended for caching use only, where it\u2019s\nacceptable for data to be lost if a machine is restarted. ",
            "selected_text": "Some in-memory key-value stores, such as Memcached, are intended for caching use only, where it\u2019s\nacceptable for data to be lost if a machine is restarted",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 861,
            "is_deleted": false,
            "representative_text": "One common reason for degradation is increased load: perhaps the system has grown from 10,000\nconcurrent users to 100,000 concurrent users, or from 1 million to 10 million. ",
            "selected_text": "One common reason for degradation is increased load",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 862,
            "is_deleted": false,
            "representative_text": "This is an important trade-off in storage systems: well-chosen indexes speed up read queries, but\nevery index slows down writes. For this reason, databases don\u2019t usually index everything by default,\nbut require you\u2014the application developer or database administrator\u2014to choose indexes\nmanually, using your knowledge of the application\u2019s typical query patterns. ",
            "selected_text": "This is an important trade-off in storage systems: well-chosen indexes speed up read queries, but\nevery index slows down writes. For this reason, databases don\u2019t usually index everything by default,\nbut require you\u2014the application developer or database administrator\u2014to choose indexes\nmanually, using your knowledge of the application\u2019s typical query patterns",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 863,
            "is_deleted": false,
            "representative_text": "Specialized query operations that are not well supported by the relational model\n\n\n",
            "selected_text": "Specialized query operations that are not well supported by the relational model",
            "color": "yellow",
            "note": "Joins ",
            "chapter": null
        },
        {
            "id": 864,
            "is_deleted": false,
            "representative_text": "Moreover, LSM-trees are typically able to sustain higher write throughput than B-trees, partly because they\nsometimes have lower write amplification (although this depends on the storage engine configuration\nand workload), and partly because they sequentially write compact SSTable files rather than having\nto overwrite several pages in the tree\n[26].\n",
            "selected_text": "B-trees, partly because they\nsometimes have lower write amplification",
            "color": "yellow",
            "note": "Consequent writes from writes growing over time",
            "chapter": null
        },
        {
            "id": 866,
            "is_deleted": false,
            "representative_text": "The map and reduce functions are somewhat restricted in what they are allowed to do. They must be\npure functions, which means they only use the data that is passed to them as input, they cannot\nperform additional database queries, and they must not have any side effects. ",
            "selected_text": "The map and reduce functions are somewhat restricted in what they are allowed to do. They must be\npure functions, which means they only use the data that is passed to them as input, they cannot\nperform additional database queries",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 867,
            "is_deleted": false,
            "representative_text": "When generating load artificially in order to test the scalability of a system, the load-generating\nclient needs to keep sending requests independently of the response time. If the client waits for\nthe previous request to complete before sending the next one, that behavior has the effect of\nartificially keeping the queues shorter in the test than they would be in reality, which skews the\nmeasurements [23].\n\n",
            "selected_text": "When generating load artificially in order to test the scalability of a system, the load-generating\nclient needs to keep sending requests independently of the response time. If the client waits for\nthe previous request to complete before sending the next one, that behavior has the effect of\nartificially keeping the queues shorter in the test than they would be in reality, which skews the\nmeasurements",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 868,
            "is_deleted": false,
            "representative_text": "If the data in your application has a document-like structure (i.e., a tree of one-to-many\nrelationships, where typically the entire tree is loaded at once), then it\u2019s probably a good idea to\nuse a document model. ",
            "selected_text": "If the data in your application has a document-like structure (i.e., a tree of one-to-many\nrelationships, where typically the entire tree is loaded at once), then it\u2019s probably a good idea to\nuse a document model",
            "color": "yellow",
            "note": "Without having to demoralize the data later in rdms, u can use document db ",
            "chapter": null
        },
        {
            "id": 869,
            "is_deleted": false,
            "representative_text": "Moreover, LSM-trees are typically able to sustain higher write throughput than B-trees, partly because they\nsometimes have lower write amplification (although this depends on the storage engine configuration\nand workload), and partly because they sequentially write compact SSTable files rather than having\nto overwrite several pages in the tree\n[26].\n",
            "selected_text": "Moreover, LSM-trees are typically able to sustain higher write throughput than",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 870,
            "is_deleted": false,
            "representative_text": "In relational databases, you can create several\nsecondary indexes on the same table using the CREATE INDEX command, and they are often crucial\nfor performing joins efficiently. ",
            "selected_text": "you can create several\nsecondary indexes on the same table using the CREATE INDEX command, and they are often crucial\nfor performing joins efficiently.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 871,
            "is_deleted": false,
            "representative_text": "to stop using their OLTP systems for analytics purposes, and to run the analytics on a separate\ndatabase instead. This separate database was called a data warehouse.\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "OLTP systems for analytics purposes, and to run the analytics on a separate\ndatabase instead. This separate database was called a data warehouse.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 872,
            "is_deleted": false,
            "representative_text": "Many data warehouses are used in a fairly formulaic\nstyle, known as a star schema (also known as dimensional modeling\n[55]).\n\n\n",
            "selected_text": "Many data warehouses are used in a fairly formulaic\nstyle, known as a star schema",
            "color": "yellow",
            "note": "Fact table in middle with dimension tables as rays of a star",
            "chapter": null
        },
        {
            "id": 873,
            "is_deleted": false,
            "representative_text": "One of the best tools we have for removing accidental complexity is abstraction. A good\nabstraction can hide a great deal of implementation detail behind a clean, simple-to-understand\nfa\u00e7ade. ",
            "selected_text": "One of the best tools we have for removing accidental complexity is abstraction. A good\nabstraction can hide a great deal of implementation detail behind a clean, simple-to-understand\nfa\u00e7ade",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 874,
            "is_deleted": false,
            "representative_text": "A B-tree index must write every piece of data at least twice: once to the write-ahead log, and once\nto the tree page itself (and perhaps again as pages are split). ",
            "selected_text": "A B-tree index must write every piece of data at least twice: once to the write-ahead log, and once\nto the tree page itself",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 875,
            "is_deleted": false,
            "representative_text": "It is impossible to reduce the probability of a fault to zero;\ntherefore it is usually best to design fault-tolerance mechanisms that prevent faults from causing\nfailures. ",
            "selected_text": "It is impossible to reduce the probability of a fault to zero;\ntherefore it is usually best to design fault-tolerance mechanisms that prevent faults from causing\nfailures",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 876,
            "is_deleted": false,
            "representative_text": "One thing that document and graph databases have in common is that they typically don\u2019t enforce a\nschema for the data they store, which can make it easier to adapt applications to changing\nrequirements. ",
            "selected_text": "One thing that document and graph databases have in common is that they typically don\u2019t enforce a\nschema for the data they store, which can make it easier to adapt applications to changing\nrequirements",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 877,
            "is_deleted": false,
            "representative_text": "It turns out\nthat the indexing algorithms discussed in the first half of this chapter work well for OLTP, but are\nnot very good at answering analytic queries. ",
            "selected_text": "It turns out\nthat the indexing algorithms discussed in the first half of this chapter work well for OLTP, but are\nnot very good at answering analytic queries",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 878,
            "is_deleted": false,
            "representative_text": "This is easy, using CSS:\n\n",
            "selected_text": "This is easy, using CSS",
            "color": "yellow",
            "note": "CSS is declarative",
            "chapter": null
        },
        {
            "id": 879,
            "is_deleted": false,
            "representative_text": "It is up to the database\nsystem\u2019s query optimizer to decide which indexes and which join methods to use, and in which order\nto execute various parts of the query.\n\n",
            "selected_text": "is up to the database\nsystem\u2019s query optimizer to decide which indexes and which join methods to use, and in which order\nto execute various parts of the query.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 880,
            "is_deleted": false,
            "representative_text": "If the database itself does not support joins, you have to emulate a join in application code by\nmaking multiple queries to the database. ",
            "selected_text": "If the database itself does not support joins, you have to emulate a join in application code by\nmaking multiple queries to the database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 881,
            "is_deleted": false,
            "representative_text": "There are many different types of objects, and it is not practical to put each type of object in\nits own table.\n\n\nThe structure of the data is determined by external systems over which you have no control and\nwhich may change at any time.\n\n\n\n",
            "selected_text": "There are many different types of objects, and it is not practical to put each type of object in\nits own table.\n\n\nThe structure of the data is determined by external systems over which you have no control and\nwhich may change at any time.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 882,
            "is_deleted": false,
            "representative_text": "Similarly to what db_set does, many databases\ninternally use a log, which is an append-only data file. ",
            "selected_text": "Similarly to what db_set does, many databases\ninternally use a log, which is an append-only data file",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 884,
            "is_deleted": false,
            "representative_text": "The column-oriented storage layout relies on each column file containing the rows in the same order.\nThus, if you need to reassemble an entire row, you can take the 23rd entry from each of the\nindividual column files and put them together to form the 23rd row of the table.\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "The column-oriented storage layout relies on each column file containing the rows in the same order.\nThus, if you need to reassemble an entire row, you can take the 23rd entry from each of the\nindividual column files and put them together to form the 23rd row of the table.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 885,
            "is_deleted": false,
            "representative_text": "The idea behind column-oriented storage is simple: don\u2019t store all the values from one row\ntogether, but store all the values from each column together instead. If each column is stored in\na separate file, a query only needs to read and parse those columns that are used in that query,\nwhich can save a lot of work. ",
            "selected_text": "The idea behind column-oriented storage is simple: don\u2019t store all the values from one row\ntogether, but store all the values from each column together instead. ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 886,
            "is_deleted": false,
            "representative_text": "One way of creating such a cache is a materialized view. In a relational data model, it is often\ndefined like a standard (virtual) view: a table-like object whose contents are the results of some\nquery. ",
            "selected_text": "One way of creating such a cache is a materialized view. In a relational data model, it is often\ndefined like a standard (virtual) view: a table-like object whose contents are the results of some\nquery",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 887,
            "is_deleted": false,
            "representative_text": "Fortunately, we have already seen a good solution earlier in this chapter: LSM-trees. All writes\nfirst go to an in-memory store, where they are added to a sorted structure and prepared for writing\nto disk. It doesn\u2019t matter whether the in-memory store is row-oriented or column-oriented. When\nenough writes have accumulated, they are merged with the column files on disk and written to new\nfiles in bulk. ",
            "selected_text": "LSM-trees. All writes\nfirst go to an in-memory store, where they are added to a sorted structure and prepared for writing\nto disk. It doesn\u2019t matter whether the in-memory store is row-oriented or column-oriented. When\nenough writes have accumulated, they are merged with the column files on disk and written to new\nfiles in bulk",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 888,
            "is_deleted": false,
            "representative_text": "However, they have the downside of making writes more difficult.\n\nAn update-in-place approach, like B-trees use, is not possible with compressed columns. If you\nwanted to insert a row in the middle of a sorted table, you would most likely have to rewrite all\nthe column files. As rows are identified by their position within a column, the insertion has to\nupdate all columns consistently.\n\n\n",
            "selected_text": "However, they have the downside of making writes more difficult.\n\nAn update-in-place approach, like B-trees use, is not possible with compressed columns. If you\nwanted to insert a row in the middle of a sorted table, you would most likely have to rewrite all\nthe column files. As rows are identified by their position within a column, the insertion has to\nupdate all columns consistently.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 889,
            "is_deleted": false,
            "representative_text": "A common special case of a materialized view is known as a data cube or OLAP cube\n[64].\n",
            "selected_text": "A common special case of a materialized view is known as a data cube or OLAP cube",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 890,
            "is_deleted": false,
            "representative_text": "The application requests records using some kind of key, and the storage engine uses an\nindex to find the data for the requested key. Disk seek time is often the bottleneck here.\n\n\n",
            "selected_text": "The application requests records using some kind of key, and the storage engine uses an\nindex to find the data for the requested key. Disk seek time is often the bottleneck here.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 891,
            "is_deleted": false,
            "representative_text": "When the underlying data changes, a materialized view needs to be updated, because it is a\ndenormalized copy of the data. The database can do that automatically, but such updates make writes\nmore expensive, which is why materialized views are not often used in OLTP databases. In read-heavy\ndata warehouses they can make more sense (whether or not they actually improve read performance\ndepends on the individual case).\n\n\n\n",
            "selected_text": "When the underlying data changes, a materialized view needs to be updated, because it is a\ndenormalized copy of the data. The database can do that automatically, but such updates make writes\nmore expensive, which is why materialized views are not often used in OLTP databases. In read-heavy\ndata warehouses they can make more sense",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 892,
            "is_deleted": false,
            "representative_text": "OLTP systems are typically user-facing, which means that they may see a huge volume of requests.\n",
            "selected_text": "OLTP systems are typically user-facing, which means that they may see a huge volume of requests",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 893,
            "is_deleted": false,
            "representative_text": "systems, but each query is typically very demanding, requiring many millions of records to be\nscanned in a short time. ",
            "selected_text": "but each query is typically very demanding, requiring many millions of records to be\nscanned in a short time",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 894,
            "is_deleted": false,
            "representative_text": "A key design goal of a service-oriented/microservices architecture is to make the application easier\nto change and maintain by making services independently deployable and evolvable. ",
            "selected_text": "A key design goal of a service-oriented/microservices architecture is to make the application easier\nto change and maintain by making services independently deployable and evolvable",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 895,
            "is_deleted": false,
            "representative_text": "WSDL enables code generation so that a client can access a remote\nservice using local classes and method calls (which are encoded to XML messages and decoded again by\nthe framework). ",
            "selected_text": "WSDL enables code generation so that a client can access a remote\nservice using local classes and method calls",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 896,
            "is_deleted": false,
            "representative_text": "Programming language\u2013specific encodings are restricted to a single programming language and often\nfail to provide forward and backward compatibility.\n\n\n",
            "selected_text": "Programming language\u2013specific encodings are restricted to a single programming language and often\nfail to provide forward and backward compatibility.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 897,
            "is_deleted": false,
            "representative_text": "Consistent Prefix Reads\n\n\n\n\n\n",
            "selected_text": "Consistent Prefix Reads",
            "color": "yellow",
            "note": "Different partitions operate at different latency. Some part of data maybe up to date and some part may be out of date.",
            "chapter": null
        },
        {
            "id": 898,
            "is_deleted": false,
            "representative_text": "The client can remember the timestamp of its most recent write\u2014then the system can ensure that the\nreplica serving any reads for that user reflects updates at least until that timestamp. ",
            "selected_text": "The client can remember the timestamp of its most recent write\u2014then the system can ensure that the\nreplica serving any reads for that user reflects updates at least until that timestamp",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 899,
            "is_deleted": false,
            "representative_text": "Many programming languages come with built-in support for encoding in-memory objects into byte\nsequences. For example, Java has java.io.Serializable\n[1], Ruby has Marshal\n[2], Python has pickle\n[3],\nand so on. ",
            "selected_text": "Many programming languages come with built-in support for encoding in-memory objects into byte\nsequences. For example, Java has java.io.Serializable\n[1], Ruby has Marshal\n[2], Python has pickle\n[3],\nand so on",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 900,
            "is_deleted": false,
            "representative_text": "Consequently, Avro doesn\u2019t have optional and required markers in the same way as Protocol\nBuffers and Thrift do (it has union types and default values instead).\n\n",
            "selected_text": "Consequently, Avro doesn\u2019t have optional and required markers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 901,
            "is_deleted": false,
            "representative_text": "The biggest problem with multi-leader replication is that write conflicts can occur, which means\nthat conflict resolution is required.\n\n",
            "selected_text": "The biggest problem with multi-leader replication is that write conflicts can occur, which means\nthat conflict resolution is required",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 902,
            "is_deleted": false,
            "representative_text": "Custom RPC protocols with a binary encoding format can achieve better performance than something\ngeneric like JSON over REST. ",
            "selected_text": "Custom RPC protocols with a binary encoding format can achieve better performance than something\ngeneric like JSON over REST",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 903,
            "is_deleted": false,
            "representative_text": "easy encoding of data, they often neglect the inconvenient problems of forward and backward\ncompatibility.\n\n\n",
            "selected_text": "they often neglect the inconvenient problems of forward and backward\ncompatibility.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 904,
            "is_deleted": false,
            "representative_text": "In the case of a B-tree (see \u201cB-Trees\u201d), which overwrites individual disk blocks,\nevery modification is first written to a write-ahead log so that the index can be restored\nto a consistent state after a crash.\n\n\n\n",
            "selected_text": "In the case of a B-tree (see \u201cB-Trees\u201d), which overwrites individual disk blocks,\nevery modification is first written to a write-ahead log so that the index can be restored\nto a consistent state after a crash.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 905,
            "is_deleted": false,
            "representative_text": "JSON distinguishes strings and numbers, but it doesn\u2019t distinguish integers and\nfloating-point numbers, and it doesn\u2019t specify a precision.\n\n",
            "selected_text": "JSON distinguishes strings and numbers, but it doesn\u2019t distinguish integers and\nfloating-point numbers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 906,
            "is_deleted": false,
            "representative_text": "When you call a local function, you can efficiently pass it references (pointers) to objects in\nlocal memory. When you make a network request, all those parameters need to be encoded into a\nsequence of bytes that can be sent over the network. ",
            "selected_text": "When you call a local function, you can efficiently pass it references (pointers) to objects in\nlocal memory. When you make a network request, all those parameters need to be encoded into a\nsequence of bytes that can be sent over the network",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 907,
            "is_deleted": false,
            "representative_text": "However, they have the\ndownside that data needs to be decoded before it is human-readable.\n\n\n\n",
            "selected_text": "However, they have the\ndownside that data needs to be decoded before it is human-readable.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 908,
            "is_deleted": false,
            "representative_text": "Each follower takes the log from the leader and updates its local copy of the\ndatabase accordingly, by applying all writes in the same order as they were processed on the\nleader.\n\n\n",
            "selected_text": "Each follower takes the log from the leader and updates its local copy of the\ndatabase accordingly,",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 909,
            "is_deleted": false,
            "representative_text": "However, for faster collaboration, you may want to make the unit of change very small (e.g., a single\nkeystroke) and avoid locking. This approach allows multiple users to edit simultaneously, but it also brings\nall the challenges of multi-leader replication, including requiring conflict resolution\n[32].\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "However, for faster collaboration, you may want to make the unit of change very small (e.g., a single\nkeystroke) and avoid locking. This approach allows multiple users to edit simultaneously, but it also brings\nall the challenges of multi-leader replication, including requiring conflict resolution",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 910,
            "is_deleted": false,
            "representative_text": "The problem with a shared-memory approach is that the cost grows faster than linearly: a machine\nwith twice as many CPUs, twice as much RAM, and twice as much disk capacity as another typically\ncosts significantly more than twice as much. ",
            "selected_text": "The problem with a shared-memory approach is that the cost grows faster than linearly",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 911,
            "is_deleted": false,
            "representative_text": "Now, if the database schema changes (for example, a table has one column added and one column\nremoved), you can just generate a new Avro schema from the updated database schema and export data in\nthe new Avro schema. The data export process does not need to pay any attention to the schema\nchange\u2014it can simply do the schema conversion every time it runs. ",
            "selected_text": "Now, if the database schema changes (for example, a table has one column added and one column\nremoved), you can just generate a new Avro schema from the updated database schema and export data in\nthe new Avro schema. The data export process does not need to pay any attention to the schema\nchange",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 912,
            "is_deleted": false,
            "representative_text": "The API of a SOAP web service is described using an XML-based language called the Web Services\nDescription Language, or WSDL. ",
            "selected_text": "The API of a SOAP web service is described using an XML-based language called the Web Services\nDescription Language, or WSDL",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 913,
            "is_deleted": false,
            "representative_text": "The main focus of RPC\nframeworks is on requests between services owned by the same organization, typically within the same\ndatacenter.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "The main focus of RPC\nframeworks is on requests between services owned by the same organization, typically within the same\ndatacenter.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 914,
            "is_deleted": false,
            "representative_text": "For example, in an application where a user can edit their own data, you can ensure that requests\nfrom a particular user are always routed to the same datacenter and use the leader in that\ndatacenter for reading and writing. ",
            "selected_text": "For example, in an application where a user can edit their own data, you can ensure that requests\nfrom a particular user are always routed to the same datacenter and use the leader in that\ndatacenter for reading and writing",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 915,
            "is_deleted": false,
            "representative_text": "By contrast, SOAP is an XML-based protocol for making network API\nrequests.vii\nAlthough it is most commonly used over HTTP, it aims to be independent from HTTP and avoids using\nmost HTTP features. ",
            "selected_text": "SOAP is an XML-based protocol for making network API\nrequests",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 916,
            "is_deleted": false,
            "representative_text": "The disadvantage is that if the synchronous\nfollower doesn\u2019t respond (because it has crashed, or there is a network fault, or for any other\nreason), the write cannot be processed. The leader must block all writes and wait until the\nsynchronous replica is available again.\n\n\n",
            "selected_text": "The disadvantage is that if the synchronous\nfollower doesn\u2019t respond (because it has crashed, or there is a network fault, or for any other\nreason), the write cannot be processed. The leader must block all writes and wait until the\nsynchronous replica is available again.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 917,
            "is_deleted": false,
            "representative_text": "A network request has another possible\noutcome: it may return without a result, due to a timeout. ",
            "selected_text": "A network request has another possible\noutcome: it may return without a result, due to a timeout",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 918,
            "is_deleted": false,
            "representative_text": "Leader-based replication has one major downside: there is only one leader, and all writes must go\nthrough it.iv If you can\u2019t connect to the leader for any reason, for example due to a network\ninterruption between you and the leader, you can\u2019t write to the database.\n\n",
            "selected_text": "Leader-based replication has one major downside: there is only one leader, and all writes must go\nthrough it",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 919,
            "is_deleted": false,
            "representative_text": "The simplest strategy for dealing with conflicts is to avoid them: if the application can ensure\nthat all writes for a particular record go through the same leader, then conflicts cannot occur.\n",
            "selected_text": "if the application can ensure\nthat all writes for a particular record go through the same leader, then conflicts cannot occur.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 920,
            "is_deleted": false,
            "representative_text": "By contrast, if you were using Thrift or Protocol Buffers for this purpose, the field tags would\nlikely have to be assigned by hand: every time the database schema changes, an administrator would\nhave to manually update the mapping from database column names to field tags. (It might be possible\nto automate this, but the schema generator would have to be very careful to not assign previously\nused field tags.) ",
            "selected_text": "By contrast, if you were using Thrift or Protocol Buffers for this purpose, the field tags would\nlikely have to be assigned by hand: every time the database schema changes, an administrator would\nhave to manually update the mapping from database column names to field tags. ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 921,
            "is_deleted": false,
            "representative_text": "Databases, where the process writing to the database encodes the data and the process reading\nfrom the database decodes it\n\n\n",
            "selected_text": "Databases, where the process writing to the database encodes the data and the process reading\nfrom the database decodes it",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 922,
            "is_deleted": false,
            "representative_text": "The web works this way: clients (web browsers) make requests to web servers, making GET requests\nto download HTML, CSS, JavaScript, images, etc., and making POST requests to submit data to the\nserver. The API consists of a standardized set of protocols and data formats (HTTP, URLs, SSL/TLS,\nHTML, etc.). Because web browsers, web servers, and website authors mostly agree on these standards,\nyou can use any web browser to access any website (at least in theory!).\n\n\n",
            "selected_text": "The web works this way: clients (web browsers) make requests to web servers, making GET requests\nto download HTML, CSS, JavaScript, images, etc., and making POST requests to submit data to the\nserver. The API consists of a standardized set of protocols and data formats (HTTP, URLs, SSL/TLS,\nHTML, etc.). Because web browsers, web servers, and website authors mostly agree on these standards,\nyou can use any web browser to access any website",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 923,
            "is_deleted": false,
            "representative_text": "JSON and XML have good support for Unicode character strings (i.e., human-readable text), but they\ndon\u2019t support binary strings (sequences of bytes without a character encoding). ",
            "selected_text": "Unicode character strings (i.e., human-readable text",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 924,
            "is_deleted": false,
            "representative_text": "Keeping a copy of the same data on several different nodes, potentially in different\n    locations. ",
            "selected_text": "Keeping a copy of the same data on several different nodes, potentially in different\n    locations",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 925,
            "is_deleted": false,
            "representative_text": "Every write to the database needs to be processed by every replica; otherwise, the replicas would no\nlonger contain the same data. The most common solution for this is called leader-based\nreplication (also known as active/passive or master\u2013slave replication) and is illustrated in\nFigure\u00a05-1. ",
            "selected_text": "Every write to the database needs to be processed by every replica; otherwise, the replicas would no\nlonger contain the same data. The most common solution for this is called leader-based\nreplication (also known as active/passive or master\u2013slave replication) and is illustrated",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 926,
            "is_deleted": false,
            "representative_text": "A logical log format is also easier for external applications to parse. This aspect is useful if you want\nto send the contents of a database to an external system, such as a data warehouse for offline\nanalysis, or for building custom indexes and caches\n[18].\n",
            "selected_text": "A logical log format is also easier for external applications to parse. This aspect is useful if you want\nto send the contents of a database to an external system",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 927,
            "is_deleted": false,
            "representative_text": "The client and the service may be implemented in different programming languages, so the RPC\nframework must translate datatypes from one language into another. ",
            "selected_text": "The client and the service may be implemented in different programming languages, so the RPC\nframework must translate datatypes from one language into another",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 928,
            "is_deleted": false,
            "representative_text": "First of all, notice that there are no tag numbers in the schema. If we encode our example record\n(Example\u00a04-1) using this schema, the Avro binary encoding is just 32 bytes long\u2014the\nmost compact of all the encodings we have seen. ",
            "selected_text": "First of all, notice that there are no tag numbers in the schema. If we encode our example record\n(Example\u00a04-1) using this schema, the Avro binary encoding is just 32 bytes long\u2014the\nmost compact of all the encodings we have seen",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 929,
            "is_deleted": false,
            "representative_text": "brokers are used as follows: one process sends a message to a named queue or topic, and the\nbroker ensures that the message is delivered to one or more consumers of or subscribers to that\nqueue or topic. There can be many producers and many consumers on the same topic.\n\n",
            "selected_text": "one process sends a message to a named queue or topic, and the\nbroker ensures that the message is delivered to one or more consumers of or subscribers to that\nqueue or topic. There can be many producers and many consumers on the same topic.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 930,
            "is_deleted": false,
            "representative_text": "In dynamically typed programming languages such as JavaScript, Ruby, or Python, there is not much\npoint in generating code, since there is no compile-time type checker to satisfy. Code generation is\noften frowned upon in these languages, since they otherwise avoid an explicit compilation step.\n",
            "selected_text": "In dynamically typed programming languages such as JavaScript, Ruby, or Python, there is not much\npoint in generating code, since there is no compile-time type checker to satisfy. Code generation is\noften frowned upon in these languages, since they otherwise avoid an explicit compilation step",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 931,
            "is_deleted": false,
            "representative_text": "A network request is unpredictable: the request or response may be\nlost due to a network problem, or the remote machine may be slow or unavailable, and such problems\nare entirely outside of your control. ",
            "selected_text": "network request is unpredictable: the request or response may be\nlost due to a network problem, or the remote machine may be slow or unavailable, and such problems\nare entirely outside of your control",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 932,
            "is_deleted": false,
            "representative_text": "Asynchronous message passing (using message brokers or actors), where nodes communicate by sending\neach other messages that are encoded by the sender and decoded by the recipient\n\n\n\n",
            "selected_text": "Asynchronous message passing (using message brokers or actors), where nodes communicate by sending\neach other messages that are encoded by the sender and decoded by the recipient",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 933,
            "is_deleted": false,
            "representative_text": "When you read data, you may see an old value; monotonic reads\nonly means that if one user makes several reads in sequence, they will not see time go\nbackward\u2014i.e., they will not read older data after having previously read newer data.\n\nOne way of achieving monotonic reads is to make sure that each user always makes their reads from\nthe same replica (different users can read from different replicas). For example, the replica can be\nchosen based on a hash of the user ID, rather than randomly. ",
            "selected_text": "monotonic reads\nonly means that if one user makes several reads in sequence, they will not see time go\nbackward\u2014i.e., they will not read older data after having previously read newer data.\n\nOne way of achieving monotonic reads is to make sure that each user always makes their reads from\nthe same replica (different users can read from different replicas). For example, the replica can be\nchosen based on a hash of the user ID",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 934,
            "is_deleted": false,
            "representative_text": "It can act as a buffer if the recipient is unavailable or overloaded, and thus improve system\nreliability.\n\n\n",
            "selected_text": "It can act as a buffer if the recipient is unavailable or overloaded",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 935,
            "is_deleted": false,
            "representative_text": "Monotonic Reads\n\n\n\n\n",
            "selected_text": "Monotonic Reads",
            "color": "yellow",
            "note": "Read query from different followers may give different results.",
            "chapter": null
        },
        {
            "id": 936,
            "is_deleted": false,
            "representative_text": "When you want to write data to a file or send it over the network, you have to encode it as some\nkind of self-contained sequence of bytes (for example, a JSON document). ",
            "selected_text": "When you want to write data to a file or send it over the network, you have to encode it as some\nkind of self-contained sequence of bytes",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 937,
            "is_deleted": false,
            "representative_text": "asynchronous: the sender doesn\u2019t wait for the message to be delivered, but simply sends it and\nthen forgets about it.\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "the sender doesn\u2019t wait for the message to be delivered, but simply sends it and\nthen forgets about it",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 938,
            "is_deleted": false,
            "representative_text": "In order to restore data in the same object types, the decoding process needs to be able to\ninstantiate arbitrary classes. ",
            "selected_text": "the decoding process needs to be able to\ninstantiate arbitrary classes",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 939,
            "is_deleted": false,
            "representative_text": "This problem does not occur in a single-leader database.\n\n\n",
            "selected_text": "This problem does not occur in a single-leader database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 940,
            "is_deleted": false,
            "representative_text": "It can automatically redeliver messages to a process that has crashed, and thus prevent messages from\nbeing lost.\n\n\n",
            "selected_text": "It can automatically redeliver messages to a process that has crashed, and thus prevent messages from\nbeing lost.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 941,
            "is_deleted": false,
            "representative_text": "Real-time collaborative editing applications allow several people to edit a document\nsimultaneously. ",
            "selected_text": "Real-time collaborative editing applications allow several people to edit a document\nsimultaneously",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 942,
            "is_deleted": false,
            "representative_text": "The best candidate for leadership is usually the replica with the most\nup-to-date data changes from the old leader (to minimize any data loss). ",
            "selected_text": "The best candidate for leadership is usually the replica with the most\nup-to-date data changes from the old leader",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 943,
            "is_deleted": false,
            "representative_text": "Problems with Replication Lag\n\n\n\n\n",
            "selected_text": "Replication Lag",
            "color": "yellow",
            "note": "Only concerned with asynchronous replication.",
            "chapter": null
        },
        {
            "id": 944,
            "is_deleted": false,
            "representative_text": "Conceptually, the process looks like this:\n\n\n\n\n\n\n\n",
            "selected_text": "Conceptually, the process looks like this:",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 945,
            "is_deleted": false,
            "representative_text": "When reading something that the user may have modified, read it from the leader; otherwise, read it\nfrom a follower. ",
            "selected_text": "When reading something that the user may have modified, read it from the leader; otherwise, read it\nfrom a follower",
            "color": "yellow",
            "note": "Strong consistency for data that matters to the user, eventual consistency for other data",
            "chapter": null
        },
        {
            "id": 946,
            "is_deleted": false,
            "representative_text": "For that reason, it is impractical for all followers to be synchronous: any one node outage would\ncause the whole system to grind to a halt. ",
            "selected_text": "For that reason, it is impractical for all followers to be synchronous: any one node outage would\ncause the whole system to grind to a halt",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 947,
            "is_deleted": false,
            "representative_text": "Another approach is the shared-disk architecture, which uses several machines with\nindependent CPUs and RAM, but stores data on an array of disks that is shared between the machines,\nwhich are connected via a fast network.ii This architecture is used\nfor some data warehousing workloads, but contention and the overhead of locking limit the\nscalability of the shared-disk approach\n[2].\n\n\n",
            "selected_text": "Another approach is the shared-disk architecture, which uses several machines with\nindependent CPUs and RAM, but stores data on an array of disks that is shared between the machines,\nwhich are connected via a fast network.ii This architecture is used\nfor some data warehousing workloads, but contention and the overhead of locking limit the\nscalability of the shared-disk approach",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 948,
            "is_deleted": false,
            "representative_text": "It allows one message to be sent to several recipients.\n\n\n",
            "selected_text": "It allows one message to be sent to several recipients.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 949,
            "is_deleted": false,
            "representative_text": "JSON is less verbose than XML, but both still use a lot of space compared to binary formats. ",
            "selected_text": "use a lot of space",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 951,
            "is_deleted": false,
            "representative_text": "It logically decouples the sender from the recipient (the sender just publishes messages and\ndoesn\u2019t care who consumes them).\n\n\n\n",
            "selected_text": "It logically decouples the sender from the recipient ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 952,
            "is_deleted": false,
            "representative_text": "To parse the binary data, you go through the fields in the order that they appear in the schema and\nuse the schema to tell you the datatype of each field. This means that the binary data can only be\ndecoded correctly if the code reading the data is using the exact same schema as the code that\nwrote the data. Any mismatch in the schema between the reader and the writer would mean incorrectly\ndecoded data.\n\n",
            "selected_text": "To parse the binary data, you go through the fields in the order that they appear in the schema and\nuse the schema to tell you the datatype of each field. This means that the binary data can only be\ndecoded correctly if the code reading the data is using the exact same schema as the code that\nwrote the data. Any mismatch in the schema between the reader and the writer would mean incorrectly\ndecoded data.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 953,
            "is_deleted": false,
            "representative_text": "The simplest\nsolution is to include a version number at the beginning of every encoded record, and to keep a\nlist of schema versions in your database. ",
            "selected_text": "The simplest\nsolution is to include a version number at the beginning of every encoded record, and to keep a\nlist of schema versions in your database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 954,
            "is_deleted": false,
            "representative_text": "Synchronous Versus Asynchronous Replication\n\n\n\n",
            "selected_text": "Synchronous Versus Asynchronous Replication",
            "color": "yellow",
            "note": "Asynchronous = eventual consistency, high availability\nSynchronous = strong consistency, low availability ",
            "chapter": null
        },
        {
            "id": 955,
            "is_deleted": false,
            "representative_text": "has gone wrong, so most systems simply use a timeout: nodes frequently bounce messages back and\nforth between each other, and if a node doesn\u2019t respond for some period of time\u2014say, 30\nseconds\u2014it is assumed to be dead. ",
            "selected_text": "so most systems simply use a timeout: nodes frequently bounce messages back and\nforth between each other, and if a node doesn\u2019t respond for some period of time\u2014say, 30\nseconds\u2014it is assumed to be dead",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 956,
            "is_deleted": false,
            "representative_text": "One solution is to make sure that any writes that are causally related to each other are written to\nthe same partition\u2014but in some applications that cannot be done efficiently. ",
            "selected_text": "One solution is to make sure that any writes that are causally related to each other are written to\nthe same partition\u2014but in some applications that cannot be done efficiently.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 957,
            "is_deleted": false,
            "representative_text": "These formats are somewhat vague about datatypes, so you have to be careful with things\nlike numbers and binary strings.\n\n\n",
            "selected_text": "These formats are somewhat vague about datatypes, so you have to be careful with things\nlike numbers and binary strings.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 958,
            "is_deleted": false,
            "representative_text": "It avoids the sender needing to know the IP address and port number of the recipient (which is\nparticularly useful in a cloud deployment where virtual machines often come and go).\n\n\n",
            "selected_text": "It avoids the sender needing to know the IP address and port number of the recipient",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 959,
            "is_deleted": false,
            "representative_text": "They are similar to RPC in that a client\u2019s request (usually\ncalled a message) is delivered to another process with low latency. They are similar to databases\nin that the message is not sent via a direct network connection, but goes via an intermediary called\na message broker (also called a message queue or message-oriented middleware), which stores\nthe message temporarily.\n\n\n\n",
            "selected_text": "They are similar to RPC in that a client\u2019s request (usually\ncalled a message) is delivered to another process with low latency. They are similar to databases\nin that the message is not sent via a direct network connection, but goes via an intermediary called\na message broker",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 960,
            "is_deleted": false,
            "representative_text": "An alternative is to use different log formats for replication and for the storage engine, which\nallows the replication log to be decoupled from the storage engine internals. This kind of\nreplication log is called a logical log, to distinguish it from the storage engine\u2019s (physical)\ndata representation.\n\n\n",
            "selected_text": "An alternative is to use different log formats for replication and for the storage engine, which\nallows the replication log to be decoupled from the storage engine internals. This kind of\nreplication log is called a logical log",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 962,
            "is_deleted": false,
            "representative_text": "possible for a user to see things moving backward in time.\n\n",
            "selected_text": "moving backward in time.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 963,
            "is_deleted": false,
            "representative_text": "JSON and XML have good support for Unicode character strings (i.e., human-readable text), but they\ndon\u2019t support binary strings (sequences of bytes without a character encoding). Binary strings are a\nuseful feature, so people get around this limitation by encoding the binary data as text using\nBase64. ",
            "selected_text": "but they\ndon\u2019t support binary strings (sequences of bytes without a character encoding). Binary strings are a\nuseful feature, so people get around this limitation by encoding the binary data as text using\nBase64",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 964,
            "is_deleted": false,
            "representative_text": "If you want synchronous conflict detection, you might as well just use\nsingle-leader replication.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "If you want synchronous conflict detection, you might as well just use\nsingle-leader replication.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 965,
            "is_deleted": false,
            "representative_text": "For workloads that consist of mostly reads and only a small percentage of writes\n(a common pattern on the web), there is an attractive option: create many followers, and distribute\nthe read requests across those followers. ",
            "selected_text": "For workloads that consist of mostly reads and only a small percentage of writes\n(a common pattern on the web), there is an attractive option: create many followers, and distribute\nthe read requests across those followers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 966,
            "is_deleted": false,
            "representative_text": "database: if you run the same query on the leader and a follower at the same time, you may get\ndifferent results, because not all writes have been reflected in the follower. ",
            "selected_text": "if you run the same query on the leader and a follower at the same time, you may get\ndifferent results, because not all writes have been reflected in the follower",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 967,
            "is_deleted": false,
            "representative_text": "hot standbys).i Whenever the leader writes new data to its local storage, it also sends the\ndata change to all of its followers as part of a  replication log or\nchange stream. ",
            "selected_text": "it also sends the\ndata change to all of its followers as part of a  replication log or\nchange stream",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 968,
            "is_deleted": false,
            "representative_text": "With Avro, forward compatibility means that you can have a new version of the schema as writer and\nan old version of the schema as reader. Conversely, backward compatibility means that you can have a\nnew version of the schema as reader and an old version as writer.\n\n",
            "selected_text": "With Avro, forward compatibility means that you can have a new version of the schema as writer and\nan old version of the schema as reader. Conversely, backward compatibility means that you can have a\nnew version of the schema as reader and an old version as writer.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 969,
            "is_deleted": false,
            "representative_text": "RPC and REST APIs, where the client encodes a request, the server decodes the request and encodes\na response, and the client finally decodes the response\n\n\n",
            "selected_text": "RPC and REST APIs, where the client encodes a request, the server decodes the request and encodes\na response, and the client finally decodes the response",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 970,
            "is_deleted": false,
            "representative_text": "Thrift has a dedicated list datatype, which is parameterized with the datatype of the list\nelements. This does not allow the same evolution from single-valued to multi-valued as Protocol\nBuffers does, but it has the advantage of supporting nested lists.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "Thrift has a dedicated list datatype, which is parameterized with the datatype of the list\nelements. This does not allow the same evolution from single-valued to multi-valued as Protocol\nBuffers does, but it has the advantage of supporting nested lists.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 971,
            "is_deleted": false,
            "representative_text": "On its local disk, each follower keeps a log of the data changes it has received from the leader. If\na follower crashes and is restarted, or if the network between the leader and the follower is\ntemporarily interrupted, the follower can recover quite easily: from its log, it knows the last\ntransaction that was processed before the fault occurred. ",
            "selected_text": "On its local disk, each follower keeps a log of the data changes it has received from the leader. ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 972,
            "is_deleted": false,
            "representative_text": "A network\nrequest is much slower than a function call, and its latency is also wildly variable: at good\ntimes it may complete in less than a millisecond, but when the network is congested or the remote\nservice is overloaded it may take many seconds to do exactly the same thing.\n\n\n",
            "selected_text": "A network\nrequest is much slower than a function call",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 973,
            "is_deleted": false,
            "representative_text": "Both Thrift and Protocol Buffers require a schema for any data that is encoded. ",
            "selected_text": "Both Thrift and Protocol Buffers require a schema for any data that is encoded",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 974,
            "is_deleted": false,
            "representative_text": "Splitting a big database into smaller subsets called partitions so that different\n    partitions can be assigned to different nodes (also known as sharding). ",
            "selected_text": "Splitting a big database into smaller subsets called partitions so that different\n    partitions can be assigned to different nodes (also known as sharding).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 975,
            "is_deleted": false,
            "representative_text": "REST is not a protocol, but rather a design philosophy that builds upon the principles of HTTP\n[34, 35].\n",
            "selected_text": "REST is not a protocol, but rather a design philosophy that builds upon the principles of HTTP\n",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 976,
            "is_deleted": false,
            "representative_text": "If you want to guarantee that there will be no editing conflicts, the application must obtain a lock\non the document before a user can edit it. If another user wants to edit the same document, they\nfirst have to wait until the first user has committed their changes and released the lock. This\ncollaboration model is equivalent to single-leader replication with transactions on the leader.\n\n",
            "selected_text": "If you want to guarantee that there will be no editing conflicts, the application must obtain a lock\non the document before a user can edit it. If another user wants to edit the same document, they\nfirst have to wait until the first user has committed their changes and released the lock. This\ncollaboration model is equivalent to single-leader replication with transactions on the leader.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 977,
            "is_deleted": false,
            "representative_text": "When two processes are communicating over a bidirectional network connection, they can negotiate\nthe schema version on connection setup and then use that schema for the lifetime of the\nconnection. ",
            "selected_text": "When two processes are communicating over a bidirectional network connection, they can negotiate\nthe schema version on connection setup and then use that schema for the lifetime of the\nconnection",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 978,
            "is_deleted": false,
            "representative_text": "If the code\nreading the data encounters a field that appears in the writer\u2019s schema but not in the reader\u2019s\nschema, it is ignored. If the code reading the data expects some field, but the writer\u2019s schema does\nnot contain a field of that name, it is filled in with a default value declared in the reader\u2019s\nschema.\n\n\n",
            "selected_text": "If the code\nreading the data encounters a field that appears in the writer\u2019s schema but not in the reader\u2019s\nschema, it is ignored. If the code reading the data expects some field, but the writer\u2019s schema does\nnot contain a field of that name, it is filled in with a default value declared in the reader\u2019s\nschema",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 979,
            "is_deleted": false,
            "representative_text": "The key idea with Avro is that the writer\u2019s schema and the reader\u2019s schema don\u2019t have to be the\nsame\u2014they only need to be compatible. When data is decoded (read), the Avro library resolves the\ndifferences by looking at the writer\u2019s schema and the reader\u2019s schema side by side and translating\nthe data from the writer\u2019s schema into the reader\u2019s schema. ",
            "selected_text": "The key idea with Avro is that the writer\u2019s schema and the reader\u2019s schema don\u2019t have to be the\nsame\u2014they only need to be compatible. When data is decoded (read), the Avro library resolves the\ndifferences by looking at the writer\u2019s schema and the reader\u2019s schema side by side and translating\nthe data from the writer\u2019s schema into the reader\u2019s schema",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 980,
            "is_deleted": false,
            "representative_text": "One of the replicas is designated the leader (also known as master or primary). When\nclients want to write to the database, they must send their requests to the leader, which first\nwrites the new data to its local storage.\n\n\n\n\n\n\n\n\n\nThe other replicas are known as followers (read replicas, slaves, secondaries, or\nhot standbys).i Whenever the leader writes new data to its local storage, it also sends the\ndata change to all of its followers as part of a  replication log or\nchange stream. ",
            "selected_text": "One of the replicas is designated the leader (also known as master or primary). When\nclients want to write to the database, they must send their requests to the leader, which first\nwrites the new data to its local storage.\n\n\n\n\n\n\n\n\n\nThe other replicas are known as followers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 981,
            "is_deleted": false,
            "representative_text": "In this setup, each leader simultaneously acts as a\nfollower to the other leaders.\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "In this setup, each leader simultaneously acts as a\nfollower to the other leaders.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 982,
            "is_deleted": false,
            "representative_text": "The encoding is often tied to a particular programming language, and reading the data in another\nlanguage is very difficult. ",
            "selected_text": "The encoding is often tied to a particular programming language",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 983,
            "is_deleted": false,
            "representative_text": "example, if you decode a database value into model objects in the application, and later reencode\nthose model objects, the unknown field might be lost in that translation process. ",
            "selected_text": "if you decode a database value into model objects in the application",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 984,
            "is_deleted": false,
            "representative_text": "There is a lot of ambiguity around the encoding of numbers. ",
            "selected_text": "There is a lot of ambiguity around the encoding of numbers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 985,
            "is_deleted": false,
            "representative_text": "When a client wants to read from the database, it can query either the leader or any of the\nfollowers. However, writes are only accepted on the leader (the followers are read-only from the\nclient\u2019s point of view).\n\n\n\n\n\n",
            "selected_text": "When a client wants to read from the database, it can query either the leader or any of the\nfollowers. However, writes are only accepted on the leader",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 986,
            "is_deleted": false,
            "representative_text": "The RPC model tries to make a request to a remote network service look the same as calling a function or\nmethod in your programming language, within the same process (this abstraction is called location\ntransparency). ",
            "selected_text": "The RPC model tries to make a request to a remote network service look the same as calling a function or\nmethod in your programming language, within the same process (this abstraction is called location\ntransparency",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 987,
            "is_deleted": false,
            "representative_text": "In the example of Figure\u00a05-2, the replication to follower 1 is\nsynchronous: the leader waits until follower 1 has confirmed that it received the write before\nreporting success to the user, and before making the write visible to other clients. The replication\nto follower 2 is asynchronous: the leader sends the message, but doesn\u2019t wait for a response from\nthe follower.\n\n",
            "selected_text": "In the example of Figure\u00a05-2, the replication to follower 1 is\nsynchronous: the leader waits until follower 1 has confirmed that it received the write before\nreporting success to the user, and before making the write visible to other clients. The replication\nto follower 2 is asynchronous:",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 988,
            "is_deleted": false,
            "representative_text": "Binary schema\u2013driven formats like Thrift, Protocol Buffers, and Avro allow compact, efficient\nencoding with clearly defined forward and backward compatibility semantics. ",
            "selected_text": "efficient\nencoding with clearly defined forward and backward compatibility semantics",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 989,
            "is_deleted": false,
            "representative_text": "You could also monitor the replication lag on followers and\nprevent queries on any follower that is more than one minute behind the leader.\n\n\n\n",
            "selected_text": "You could also monitor the replication lag on followers and\nprevent queries on any follower that is more than one minute behind the leader.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 990,
            "is_deleted": false,
            "representative_text": "Any statement that calls a nondeterministic function, such as NOW() to get the current date\nand time or RAND() to get a random number, is likely to generate a different value on each\nreplica.\n\n\n",
            "selected_text": "Any statement that calls a nondeterministic function, such as NOW() to get the current date\nand time or RAND() to get a random number, is likely to generate a different value on each\nreplica.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 991,
            "is_deleted": false,
            "representative_text": "As multi-leader replication is a somewhat retrofitted feature in many databases, there are often\nsubtle configuration pitfalls and surprising interactions with other database features. For example,\nautoincrementing keys, triggers, and integrity constraints can be problematic. For this reason,\nmulti-leader replication is often considered dangerous territory that should be avoided if possible\n[28].\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "As multi-leader replication is a somewhat retrofitted feature in many databases, there are often\nsubtle configuration pitfalls and surprising interactions with other database features. For example,\nautoincrementing keys, triggers, and integrity constraints can be problematic. For this reason,\nmulti-leader replication is often considered dangerous territory that should be avoided if possible",
            "color": "yellow",
            "note": "Retrofitted = add on",
            "chapter": null
        },
        {
            "id": 992,
            "is_deleted": false,
            "representative_text": "example, if you decode a database value into model objects in the application, and later reencode\nthose model objects, the unknown field might be lost in that translation process. Solving this is\nnot a hard problem; you just need to be aware of it.\n\n\n",
            "selected_text": "and later reencode\nthose model objects, the unknown field might be lost in that translation process. Solving this is\nnot a hard problem; you just need to be aware of it.\n\n\n",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 993,
            "is_deleted": false,
            "representative_text": "For example, consider the calendar apps on your mobile phone, your laptop, and other devices. You\nneed to be able to see your meetings (make read requests) and enter new meetings (make write\nrequests) at any time, regardless of whether your device currently has an internet connection. If\nyou make any changes while you are offline, they need to be synced with a server and your other\ndevices when the device is next online.\n\n\nIn this case, every device has a local database that acts as a leader (it accepts write requests),\nand there is an asynchronous multi-leader replication process (sync) between the replicas of your\ncalendar on all of your devices. The replication lag may be hours or even days, depending on when\nyou have internet access available.\n\n",
            "selected_text": "For example, consider the calendar apps on your mobile phone, your laptop, and other devices. You\nneed to be able to see your meetings (make read requests) and enter new meetings (make write\nrequests) at any time, regardless of whether your device currently has an internet connection. If\nyou make any changes while you are offline, they need to be synced with a server and your other\ndevices when the device is next online.\n\n\nIn this case, every device has a local database that acts as a leader (it accepts write requests),\nand there is an asynchronous multi-leader replication process (sync) between the replicas of your\ncalendar on all of your devices. The replication lag may be hours or even days, depending on when\nyou have internet access available.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 994,
            "is_deleted": false,
            "representative_text": "RESTful APIs tend to favor simpler approaches, typically involving less code generation and\nautomated tooling. ",
            "selected_text": "RESTful APIs tend to favor simpler approaches, typically involving less code generation and\nautomated tooling",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 995,
            "is_deleted": false,
            "representative_text": "In practice, if you enable synchronous replication on a\ndatabase, it usually means that one of the followers is synchronous, and the others are\nasynchronous. If the synchronous follower becomes unavailable or slow, one of the asynchronous\nfollowers is made synchronous. This guarantees that you have an up-to-date copy of the data on at\nleast two nodes: the leader and one synchronous follower. This configuration is sometimes also\ncalled semi-synchronous [7].\n\n",
            "selected_text": "In practice, if you enable synchronous replication on a\ndatabase, it usually means that one of the followers is synchronous, and the others are\nasynchronous. If the synchronous follower becomes unavailable or slow, one of the asynchronous\nfollowers is made synchronous. This guarantees that you have an up-to-date copy of the data on at\nleast two nodes: the leader and one synchronous follower. This configuration is sometimes also\ncalled semi-synchronous [7].",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 996,
            "is_deleted": false,
            "representative_text": "Often, leader-based replication is configured to be completely asynchronous. In this case, if the\nleader fails and is not recoverable, any writes that have not yet been replicated to followers are\nlost. This means that a write is not guaranteed to be durable, even if it has been confirmed to the\nclient. However, a fully asynchronous configuration has the advantage that the leader can continue\nprocessing writes, even if all of its followers have fallen behind.\n\n",
            "selected_text": "Often, leader-based replication is configured to be completely asynchronous. In this case, if the\nleader fails and is not recoverable, any writes that have not yet been replicated to followers are\nlost. This means that a write is not guaranteed to be durable, even if it has been confirmed to the\nclient. However, a fully asynchronous configuration has the advantage that the leader can continue\nprocessing writes, even if all of its followers have fallen behind.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 997,
            "is_deleted": false,
            "representative_text": "construct manually, users of SOAP rely heavily on tool support, code generation, and IDEs\n[38].\n",
            "selected_text": "users of SOAP rely heavily on tool support, code generation, and IDEs\n",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 998,
            "is_deleted": false,
            "representative_text": "For RESTful APIs, common approaches are to use a version\nnumber in the URL or in the HTTP Accept header. ",
            "selected_text": "For RESTful APIs, common approaches are to use a version\nnumber in the URL or in the HTTP Accept header",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 999,
            "is_deleted": false,
            "representative_text": "Preventing this kind of anomaly requires another type of guarantee: consistent prefix reads\n[23]. This guarantee says that if a sequence of\nwrites happens in a certain order, then anyone reading those writes will see them appear in the same\norder.\n\n",
            "selected_text": "Preventing this kind of anomaly requires another type of guarantee: consistent prefix reads\n[23]. This guarantee says that if a sequence of\nwrites happens in a certain order, then anyone reading those writes will see them appear in the same\norder",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1000,
            "is_deleted": false,
            "representative_text": "Some data storage systems take a different approach, abandoning the concept of a leader and\nallowing any replica to directly accept writes from clients. ",
            "selected_text": "Some data storage systems take a different approach, abandoning the concept of a leader and\nallowing any replica to directly accept writes from clients",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1001,
            "is_deleted": false,
            "representative_text": "Although this approach\nis popular, it is dangerously prone to data loss\n[35].\n",
            "selected_text": "Although this approach\nis popular, it is dangerously prone to data loss\n[35].",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1003,
            "is_deleted": false,
            "representative_text": "It makes no promises about other users: other users\u2019 updates may not be\nvisible until some later time. However, it reassures the user that their own input has been saved\ncorrectly.\n\n",
            "selected_text": "other users\u2019 updates may not be\nvisible until some later time. However, it reassures the user that their own input has been saved\ncorrectly.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1004,
            "is_deleted": false,
            "representative_text": "In this situation, we need read-after-write consistency, also known as read-your-writes consistency\n[24].\nThis is a guarantee that if the user reloads the page, they will always see any updates they\nsubmitted themselves. ",
            "selected_text": "read-your-writes consistency\n[24].\nThis is a guarantee that if the user reloads the page, they will always see any updates they\nsubmitted themselves.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1006,
            "is_deleted": false,
            "representative_text": "This is a particular problem in partitioned (sharded) databases, which we will discuss in\nChapter\u00a06. ",
            "selected_text": "This is a particular problem in partitioned (sharded) databases",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1007,
            "is_deleted": false,
            "representative_text": "picked based on geographic proximity to the user), but from any one user\u2019s point of view the\nconfiguration is essentially single-leader.\n\n",
            "selected_text": "but from any one user\u2019s point of view the\nconfiguration is essentially single-leader.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1008,
            "is_deleted": false,
            "representative_text": "densely connected topology (such as all-to-all) is better because it allows messages to travel\nalong different paths, avoiding a single point of failure.\n\n",
            "selected_text": "better because it allows messages to travel\nalong different paths, avoiding a single point of failure.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1009,
            "is_deleted": false,
            "representative_text": "In a multi-leader configuration, there is no defined ordering of writes, so it\u2019s not clear what the\nfinal value should be. ",
            "selected_text": "In a multi-leader configuration, there is no defined ordering of writes, so it\u2019s not clear what the\nfinal value should be",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1010,
            "is_deleted": false,
            "representative_text": "The application may\nprompt the user or automatically resolve the conflict, and write the result back to the database.\nCouchDB works this way, for example.\n\n\n\n",
            "selected_text": "application may\nprompt the user or automatically resolve the conflict, and write the result back to the database.\nCouchDB works this way, for example",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1011,
            "is_deleted": false,
            "representative_text": "Thus, the database must resolve the conflict in a convergent way, which means that all\nreplicas must arrive at the same final value when all changes have been replicated.\n\n",
            "selected_text": "the database must resolve the conflict in a convergent way, which means that all\nreplicas must arrive at the same final value when all changes have been replicated.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1013,
            "is_deleted": false,
            "representative_text": "On the other hand, in a leaderless configuration, failover does not exist.\n",
            "selected_text": "On the other hand, in a leaderless configuration, failover does not exist",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1014,
            "is_deleted": false,
            "representative_text": "one replica: read requests are also sent to several nodes in parallel. ",
            "selected_text": "read requests are also sent to several nodes in parallel.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1015,
            "is_deleted": false,
            "representative_text": "In this situation, it\u2019s likely that fewer than w or r\nreachable nodes remain, so the client can no longer reach a quorum.\n\n",
            "selected_text": "In this situation, it\u2019s likely that fewer than w or r\nreachable nodes remain, so the client can no longer reach a quorum.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1017,
            "is_deleted": false,
            "representative_text": "A multi-leader configuration with asynchronous replication can\nusually tolerate network problems better: a temporary network interruption does not prevent writes\nbeing processed.\n\n\n\n\n\n\n\n",
            "selected_text": "A multi-leader configuration with asynchronous replication can\nusually tolerate network problems better: a temporary network interruption does not prevent writes\nbeing processed",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1018,
            "is_deleted": false,
            "representative_text": "Each write from a client\nis sent to all replicas, regardless of datacenter, but the client usually only waits for\nacknowledgment from a quorum of nodes within its local datacenter so that it is unaffected by\ndelays and interruptions on the cross-datacenter link. ",
            "selected_text": "Each write from a client\nis sent to all replicas, regardless of datacenter, but the client usually only waits for\nacknowledgment from a quorum of nodes within its local datacenter so that it is unaffected by\ndelays and interruptions on the cross-datacenter link",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1020,
            "is_deleted": false,
            "representative_text": "The client sees that replica 3 has a stale\nvalue and writes the newer value back to that replica. This approach works well for values that are\nfrequently read.\n\n",
            "selected_text": "The client sees that replica 3 has a stale\nvalue and writes the newer value back to that replica. This approach works well for values that are\nfrequently read.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1021,
            "is_deleted": false,
            "representative_text": "In addition, some datastores have a background process that constantly looks for differences in\nthe data between replicas and copies any missing data from one replica to another. ",
            "selected_text": "background process that constantly looks for differences in\nthe data between replicas and copies any missing data from one replica to another",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1022,
            "is_deleted": false,
            "representative_text": "database (e.g., UPDATE \u2026 WHERE <some condition>), they must be executed in exactly the same\norder on each replica, or else they may have a different effect. ",
            "selected_text": "they must be executed in exactly the same\norder on each replica",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1023,
            "is_deleted": false,
            "representative_text": "In Dynamo-style databases, the parameters n, w, and r are typically configurable. A common\nchoice is to make n an odd number (typically 3 or 5) and to set w = r =\n(n\u00a0+\u00a01)\u00a0/\u00a02 (rounded up). ",
            "selected_text": "In Dynamo-style databases, the parameters n, w, and r are typically configurable. A common\nchoice is to make n an odd number (typically 3 or 5) and to set w = r =\n(n\u00a0+\u00a01)\u00a0/\u00a02 (rounded up",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1026,
            "is_deleted": false,
            "representative_text": "The parameters w and r allow you to adjust the probability of stale values\nbeing read, but it\u2019s wise to not take them as absolute guarantees.\n\n",
            "selected_text": "The parameters w and r allow you to adjust the probability of stale values\nbeing read, but it\u2019s wise to not take them as absolute guarantees.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1027,
            "is_deleted": false,
            "representative_text": "Thus, the inter-datacenter network delay is hidden from\nusers, which means the perceived performance may be better.\n\n",
            "selected_text": "Thus, the inter-datacenter network delay is hidden from\nusers, which means the perceived performance may be better",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1028,
            "is_deleted": false,
            "representative_text": "These\ncharacteristics make databases with leaderless replication appealing for use cases that require\nhigh availability and low latency, and that can tolerate occasional stale reads.\n\n",
            "selected_text": "These\ncharacteristics make databases with leaderless replication appealing for use cases that require\nhigh availability and low latency, and that can tolerate occasional stale reads.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1029,
            "is_deleted": false,
            "representative_text": "replication log in leader-based replication, this anti-entropy process does not copy writes in\nany particular order, and there may be a significant delay before data is copied.\n\n\n\n\n",
            "selected_text": "does not copy writes in\nany particular order",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1030,
            "is_deleted": false,
            "representative_text": "By subtracting a follower\u2019s current position from the leader\u2019s\ncurrent position, you can measure the amount of replication lag.\n\n",
            "selected_text": "By subtracting a follower\u2019s current position from the leader\u2019s\ncurrent position, you can measure the amount of replication lag.",
            "color": "yellow",
            "note": "Calculate lag for leader based replication.",
            "chapter": null
        },
        {
            "id": 1033,
            "is_deleted": false,
            "representative_text": "This algorithm ensures that no data is silently dropped, but it unfortunately requires that the\nclients do some extra work: if several operations happen concurrently, clients have to clean up\nafterward by merging the concurrently written values. ",
            "selected_text": "but it unfortunately requires that the\nclients do some extra work: if several operations happen concurrently, clients have to clean up\nafterward by merging the concurrently written values",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1034,
            "is_deleted": false,
            "representative_text": "in fact, it is not important whether they literally overlap in time. Because of problems with clocks\nin distributed systems, it is actually quite difficult to tell whether two things happened\nat exactly the same time\u2014an issue we will discuss in more detail in Chapter\u00a08.\n\n",
            "selected_text": "it is not important whether they literally overlap in time. Because of problems with clocks\nin distributed systems, it is actually quite difficult to tell whether two things happened\nat exactly the same time",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1035,
            "is_deleted": false,
            "representative_text": "Thus, you\nalso need some way of keeping track of which keys are being split.\n\n",
            "selected_text": "you\nalso need some way of keeping track of which keys are being split.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1036,
            "is_deleted": false,
            "representative_text": "Our goal with partitioning is to spread the data and the query load evenly across nodes. ",
            "selected_text": "Our goal with partitioning is to spread the data and the query load evenly across nodes.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1037,
            "is_deleted": false,
            "representative_text": "Most database vendors recommend that you structure\nyour partitioning scheme so that secondary index queries can be served from a single partition, but\nthat is not always possible, especially when you\u2019re using multiple secondary indexes in a single\nquery (such as filtering cars by color and by make at the same time).\n\n\n",
            "selected_text": "Most database vendors recommend that you structure\nyour partitioning scheme so that secondary index queries can be served from a single partition",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1038,
            "is_deleted": false,
            "representative_text": "However, if you want to allow people to also remove things from their carts, and not just add\nthings, then taking the union of siblings may not yield the right result: if you merge two sibling\ncarts and an item has been removed in only one of them, then the removed item will reappear in the\nunion of the siblings [37]. ",
            "selected_text": "However, if you want to allow people to also remove things from their carts, and not just add\nthings, then taking the union of siblings may not yield the right result: if you merge two sibling\ncarts and an item has been removed in only one of them, then the removed item will reappear in the\nunion of the siblings",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1039,
            "is_deleted": false,
            "representative_text": "A global\nindex must also be partitioned, but it can be partitioned differently from the primary key index.\n\n",
            "selected_text": "A global\nindex must also be partitioned, but it can be partitioned differently from the primary key index",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1040,
            "is_deleted": false,
            "representative_text": "We call this kind of index term-partitioned, because the term we\u2019re looking for determines the partition\nof the index. ",
            "selected_text": "We call this kind of index term-partitioned, because the term we\u2019re looking for determines the partition\nof the index",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1041,
            "is_deleted": false,
            "representative_text": "We also say that B is causally dependent on A.\n\n\n",
            "selected_text": "We also say that B is causally dependent on A.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1042,
            "is_deleted": false,
            "representative_text": "Unfortunately however, by using the hash of the key for partitioning we lose a nice property of\nkey-range partitioning: the ability to do efficient range queries. Keys that were once adjacent are\nnow scattered across all the partitions, so their sort order is lost. ",
            "selected_text": "Unfortunately however, by using the hash of the key for partitioning we lose a nice property of\nkey-range partitioning: the ability to do efficient range queries. Keys that were once adjacent are\nnow scattered across all the partitions, so their sort order is lost",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1044,
            "is_deleted": false,
            "representative_text": "The main reason for wanting to partition data is scalability. Different partitions can be placed\non different nodes in a shared-nothing cluster (see the introduction to Part\u00a0II\nfor a definition of shared nothing). ",
            "selected_text": "The main reason for wanting to partition data is scalability. Different partitions can be placed\non different nodes in a shared-nothing cluster",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1045,
            "is_deleted": false,
            "representative_text": "The only safe way of using a database with LWW is to ensure that a key is only written once and\nthereafter treated as immutable, thus avoiding any concurrent updates to the same key. For example,\na recommended way of using Cassandra is to use a UUID as the key, thus giving each write operation a\nunique key [53].\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "The only safe way of using a database with LWW is to ensure that a key is only written once and\nthereafter treated as immutable, thus avoiding any concurrent updates to the same key. For example,\na recommended way of using Cassandra is to use a UUID as the key, thus giving each write operation a\nunique key",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1046,
            "is_deleted": false,
            "representative_text": "A simple\napproach is to just pick one of the values based on a version number or timestamp (last write wins),\nbut that implies losing data. ",
            "selected_text": "A simple\napproach is to just pick one of the values based on a version number or timestamp (last write wins),\nbut that implies losing data",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1047,
            "is_deleted": false,
            "representative_text": "The collection of version numbers from all the replicas is called a version vector\n[56].\n",
            "selected_text": "The collection of version numbers from all the replicas is called a version vector",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1048,
            "is_deleted": false,
            "representative_text": "If partitions are very large, rebalancing and recovery from\nnode failures become expensive. But if partitions are too small, they incur too much overhead. The\nbest performance is achieved when the size of partitions is \u201cjust right,\u201d neither too big nor too\nsmall, which can be hard to achieve if the number of partitions is fixed but the dataset size\nvaries.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "If partitions are very large, rebalancing and recovery from\nnode failures become expensive. But if partitions are too small, they incur too much overhead. The\nbest performance is achieved when the size of partitions is \u201cjust right,\u201d neither too big nor too\nsmall, which can be hard to achieve if the number of partitions is fixed but the dataset size\nvaries.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1049,
            "is_deleted": false,
            "representative_text": "If one operation happened before another, the later\noperation should overwrite the earlier operation, but if the operations are concurrent, we have a\nconflict that needs to be resolved.\n\n",
            "selected_text": "If one operation happened before another, the later\noperation should overwrite the earlier operation, but if the operations are concurrent, we have a\nconflict that needs to be resolved",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1050,
            "is_deleted": false,
            "representative_text": "Just a two-digit decimal random number would split the writes to the key evenly across 100 different\nkeys, allowing those keys to be distributed to different partitions.\n\nHowever, having split the writes across different keys, any reads now have to do additional work, as\nthey have to read the data from all 100 keys and combine it. ",
            "selected_text": "Just a two-digit decimal random number would split the writes to the key evenly across 100 different\nkeys, allowing those keys to be distributed to different partitions.\n\nHowever, having split the writes across different keys, any reads now have to do additional work, as\nthey have to read the data from all 100 keys and combine it",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1051,
            "is_deleted": false,
            "representative_text": "Partitioning is usually combined with replication so that copies of each partition are stored on\nmultiple nodes. This means that, even though each record belongs to exactly one partition, it may\nstill be stored on several different nodes for fault tolerance.\n\n",
            "selected_text": "Partitioning is usually combined with replication so that copies of each partition are stored on\nmultiple nodes. This means that, even though each record belongs to exactly one partition, it may\nstill be stored on several different nodes for fault tolerance",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1052,
            "is_deleted": false,
            "representative_text": "The process of\nmoving load from one node in the cluster to another is called rebalancing.\n\n",
            "selected_text": "The process of\nmoving load from one node in the cluster to another is called rebalancing",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1053,
            "is_deleted": false,
            "representative_text": "Because of this risk of skew and hot spots, many distributed datastores use a hash function to\ndetermine the partition for a given key.\n\n",
            "selected_text": "Because of this risk of skew and hot spots, many distributed datastores use a hash function to\ndetermine the partition for a given key.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1054,
            "is_deleted": false,
            "representative_text": "The advantage of a global (term-partitioned) index over a document-partitioned index is that it can\nmake reads more efficient: rather than doing scatter/gather over all partitions, a client only needs\nto make a request to the partition containing the term that it wants. However, the downside of a\nglobal index is that writes are slower and more complicated, because a write to a single\ndocument may now affect multiple partitions of the index (every term in the document might be on a\ndifferent partition, on a different node).\n\n",
            "selected_text": "The advantage of a global (term-partitioned) index over a document-partitioned index is that it can\nmake reads more efficient: rather than doing scatter/gather over all partitions, a client only needs\nto make a request to the partition containing the term that it wants. However, the downside of a\nglobal index is that writes are slower and more complicated, because a write to a single\ndocument may now affect multiple partitions of the index",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1055,
            "is_deleted": false,
            "representative_text": "Rather than each partition having its own secondary index (a local index), we can construct a\nglobal index that covers data in all partitions. ",
            "selected_text": "Rather than each partition having its own secondary index (a local index), we can construct a\nglobal index that covers data in all partitions.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1056,
            "is_deleted": false,
            "representative_text": "Consistent hashing, as defined by Karger et al.\n[7],\nis a way of evenly distributing load across an internet-wide system of caches such as a content\ndelivery network (CDN). It uses randomly chosen partition boundaries to avoid the need for central\ncontrol or distributed consensus. Note that consistent here has nothing to do with replica\nconsistency (see Chapter\u00a05) or ACID consistency (see Chapter\u00a07), but rather\ndescribes a particular approach to rebalancing.\n\n",
            "selected_text": "Consistent hashing, as defined by Karger et al.\n[7],\nis a way of evenly distributing load across an internet-wide system of caches such as a content\ndelivery network (CDN). It uses randomly chosen partition boundaries to avoid the need for central\ncontrol or distributed consensus. Note that consistent here has nothing to do with replica\nconsistency (see Chapter\u00a05) or ACID consistency (see Chapter\u00a07), but rather\ndescribes a particular approach to rebalancing.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1058,
            "is_deleted": false,
            "representative_text": "Thus, if you want to search for red cars, you need to\nsend the query to all partitions, and combine all the results you get back.\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "Thus, if you want to search for red cars, you need to\nsend the query to all partitions, and combine all the results you get back",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1059,
            "is_deleted": false,
            "representative_text": "this problem, an item cannot simply be deleted from the database when it is removed; instead, the\nsystem must leave a marker with an appropriate version number to indicate that the item has been\nremoved when merging siblings.  Such a deletion marker is known as a tombstone.\n",
            "selected_text": "instead, the\nsystem must leave a marker with an appropriate version number to indicate that the item has been\nremoved when merging siblings.  Such a deletion marker is known as a tombstone",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1060,
            "is_deleted": false,
            "representative_text": "Normally, partitions are defined in such a way that each piece of data (each record, row, or\ndocument) belongs to exactly one partition. ",
            "selected_text": "Normally, partitions are defined in such a way that each piece of data (each record, row, or\ndocument) belongs to exactly one partition",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1061,
            "is_deleted": false,
            "representative_text": "With the example of a shopping cart, a reasonable approach to merging siblings is to just take the\nunion. ",
            "selected_text": "With the example of a shopping cart, a reasonable approach to merging siblings is to just take the\nunion",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1062,
            "is_deleted": false,
            "representative_text": "If a node is removed from the cluster, the same happens in\nreverse.\n\nOnly entire partitions are moved between nodes. The number of partitions does not change, nor does\nthe assignment of keys to partitions. ",
            "selected_text": "If a node is removed from the cluster, the same happens in\nreverse.\n\nOnly entire partitions are moved between nodes. The number of partitions does not change, nor does\nthe assignment of keys to partitions",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1063,
            "is_deleted": false,
            "representative_text": "We need an approach that doesn\u2019t move data around more than necessary.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "We need an approach that doesn\u2019t move data around more than necessary",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1064,
            "is_deleted": false,
            "representative_text": "A secondary index usually doesn\u2019t identify a record uniquely but\nrather is a way of searching for occurrences of a particular value: find all actions by user\n123, find all articles containing the word hogwash, find all cars whose color is red, and so\non.\n\n\n",
            "selected_text": "A secondary index usually doesn\u2019t identify a record uniquely but\nrather is a way of searching for occurrences of a particular value",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1065,
            "is_deleted": false,
            "representative_text": "Cassandra achieves a compromise between the two partitioning strategies\n[11,\n12,\n13].\nA table in Cassandra can be declared with a compound primary key consisting of several columns.\nOnly the first part of that key is hashed to determine the partition, but the other columns are used\nas a concatenated index for sorting the data in Cassandra\u2019s SSTables. A query therefore cannot\nsearch for a range of values within the first column of a compound key, but if it specifies a fixed\nvalue for the first column, it can perform an efficient range scan over the other columns of the\nkey.\n\n\nThe concatenated index approach enables an elegant data model for one-to-many relationships. For\nexample, on a social media site, one user may post many updates. If the primary key for updates is\nchosen to be (user_id, update_timestamp), then you can efficiently retrieve all updates made by a\nparticular user within some time interval, sorted by timestamp. Different users may be stored on\ndifferent partitions, but within each user, the updates are stored ordered by timestamp on a single\npartition.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "Cassandra achieves a compromise between the two partitioning strategies\n[11,\n12,\n13].\nA table in Cassandra can be declared with a compound primary key consisting of several columns.\nOnly the first part of that key is hashed to determine the partition, but the other columns are used\nas a concatenated index for sorting the data in Cassandra\u2019s SSTables. A query therefore cannot\nsearch for a range of values within the first column of a compound key, but if it specifies a fixed\nvalue for the first column, it can perform an efficient range scan over the other columns of the\nkey.\n\n\nThe concatenated index approach enables an elegant data model for one-to-many relationships. For\nexample, on a social media site, one user may post many updates. If the primary key for updates is\nchosen to be (user_id, update_timestamp), then you can efficiently retrieve all updates made by a\nparticular user within some time interval, sorted by timestamp. Different users may be stored on\ndifferent partitions, but within each user, the updates are stored ordered by timestamp on a single\npartition.",
            "color": "yellow",
            "note": "This is what we did for performing range queries on model history.. we store a pair of session id and timestamp as composite key. The timestamp is used for maintaining the sorted order of the conversation and the session id is used for the hash. This allows us to perform efficient range queries since we have a one to many model.",
            "chapter": null
        },
        {
            "id": 1066,
            "is_deleted": false,
            "representative_text": "Even if the input strings are very similar, their\nhashes are evenly distributed across that range of numbers.\n\n\n\n\n\n\n\n",
            "selected_text": "Even if the input strings are very similar, their\nhashes are evenly distributed across that range of numbers.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1067,
            "is_deleted": false,
            "representative_text": "Now, if a node is added to the cluster, the new node can steal a few partitions from every\nexisting node until partitions are fairly distributed once again. ",
            "selected_text": "Now, if a node is added to the cluster, the new node can steal a few partitions from every\nexisting node until partitions are fairly distributed once again",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1068,
            "is_deleted": false,
            "representative_text": "The presence of skew makes partitioning much less effective. In an extreme case, all the load\ncould end up on one partition, so 9 out of 10 nodes are idle and your bottleneck is the\nsingle busy node. A partition with disproportionately high load is called a hot spot.\n\n",
            "selected_text": "The presence of skew makes partitioning much less effective. In an extreme case, all the load\ncould end up on one partition, so 9 out of 10 nodes are idle and your bottleneck is the\nsingle busy node. A partition with disproportionately high load is called a hot spot.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1070,
            "is_deleted": false,
            "representative_text": "Isolation in the sense of ACID means that concurrently executing transactions are isolated from\neach other: they cannot step on each other\u2019s toes. The classic database textbooks formalize\nisolation as serializability, which means that each transaction can pretend that it is the only\ntransaction running on the entire database. ",
            "selected_text": "Isolation in the sense of ACID means that concurrently executing transactions are isolated from\neach other: they cannot step on each other\u2019s toes. The classic database textbooks formalize\nisolation as serializability, which means that each transaction can pretend that it is the only\ntransaction running on the entire database.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1071,
            "is_deleted": false,
            "representative_text": "In general, atomic refers to something that cannot be broken down into smaller parts. ",
            "selected_text": "In general, atomic refers to something that cannot be broken down into smaller parts",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1072,
            "is_deleted": false,
            "representative_text": "The purpose of a database system is to provide a safe place where data can be stored without fear of\nlosing it. Durability is the promise that once a transaction has committed successfully, any data it\nhas written will not be forgotten, even if there is a hardware fault or the database crashes.\n\n",
            "selected_text": "The purpose of a database system is to provide a safe place where data can be stored without fear of\nlosing it. Durability is the promise that once a transaction has committed successfully, any data it\nhas written will not be forgotten, even if there is a hardware fault or the database crashes.\n\n",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1073,
            "is_deleted": false,
            "representative_text": "When reading from the database, you will only see data that has been committed (no dirty\nreads).\n\n\n",
            "selected_text": "When reading from the database, you will only see data that has been committed (no dirty\nreads).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1074,
            "is_deleted": false,
            "representative_text": "To implement snapshot isolation, databases use a generalization of the mechanism we saw for\npreventing dirty reads in Figure\u00a07-4. ",
            "selected_text": "To implement snapshot isolation, databases use a generalization of the mechanism we saw for\npreventing dirty reads",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1075,
            "is_deleted": false,
            "representative_text": "However, you might find this query to be too slow if there are many emails, and decide to store the\nnumber of unread messages in a separate field (a kind of denormalization). ",
            "selected_text": "you might find this query to be too slow if there are many emails, and decide to store the\nnumber of unread messages in a separate field (a kind of denormalization",
            "color": "yellow",
            "note": "By demoralizing, you agree to store redundant data to answer some queries in less time.",
            "chapter": null
        },
        {
            "id": 1076,
            "is_deleted": false,
            "representative_text": "Imagine a transaction has written some data to the database, but the transaction has not yet committed or aborted.\nCan another transaction see that uncommitted data? If yes, that is called a\ndirty read [2].\n\n",
            "selected_text": "Imagine a transaction has written some data to the database, but the transaction has not yet committed or aborted.\nCan another transaction see that uncommitted data? If yes, that is called a\ndirty read",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1077,
            "is_deleted": false,
            "representative_text": "The idea is that each transaction reads from a consistent snapshot of\nthe database\u2014that is, the transaction sees all the data that was committed in the database at the\nstart of the transaction. ",
            "selected_text": "The idea is that each transaction reads from a consistent snapshot of\nthe database\u2014that is, the transaction sees all the data that was committed in the database at the\nstart of the transaction",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1078,
            "is_deleted": false,
            "representative_text": "For example, in Figure\u00a07-2, the\nuser sees the new unread email but not the updated counter. This is a dirty read of the email.\nSeeing the database in a partially updated state is confusing to users and may cause other\ntransactions to take incorrect decisions.\n\n\n",
            "selected_text": "For example, in Figure\u00a07-2, the\nuser sees the new unread email but not the updated counter. This is a dirty read of the email.\nSeeing the database in a partially updated state is confusing to users and may cause other\ntransactions to take incorrect decisions.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1079,
            "is_deleted": false,
            "representative_text": "If a database only needed to provide read committed isolation, but not snapshot isolation, it would\nbe sufficient to keep two versions of an object: the committed version and the\noverwritten-but-not-yet-committed version. However, storage engines that support snapshot isolation\ntypically use MVCC for their read committed isolation level as well. A typical approach is that read\ncommitted uses a separate snapshot for each query, while snapshot isolation uses the same snapshot\nfor an entire transaction.\n\n\n",
            "selected_text": "If a database only needed to provide read committed isolation, but not snapshot isolation, it would\nbe sufficient to keep two versions of an object: the committed version and the\noverwritten-but-not-yet-committed version. However, storage engines that support snapshot isolation\ntypically use MVCC for their read committed isolation level as well. A typical approach is that read\ncommitted uses a separate snapshot for each query, while snapshot isolation uses the same snapshot\nfor an entire transaction",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1080,
            "is_deleted": false,
            "representative_text": "completed (committed) due to a fault, then the transaction is aborted and the database must\ndiscard or undo any writes it has made so far in that transaction.\n\n",
            "selected_text": "database must\ndiscard or undo any writes it has made so far in that transaction.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1081,
            "is_deleted": false,
            "representative_text": "Transactions running at the read\ncommitted isolation level must prevent dirty writes, usually by delaying the second write until the\nfirst write\u2019s transaction has committed or aborted.\n\n",
            "selected_text": "Transactions running at the read\ncommitted isolation level must prevent dirty writes, usually by delaying the second write until the\nfirst write\u2019s transaction has committed or aborted.\n\n",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1082,
            "is_deleted": false,
            "representative_text": "However, the approach of requiring read locks does not work well in practice, because one\nlong-running write transaction can force many read-only transactions to wait until the long-running\ntransaction has completed. ",
            "selected_text": "However, the approach of requiring read locks does not work well in practice, because one\nlong-running write transaction can force many read-only transactions to wait until the long-running\ntransaction has completed",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1083,
            "is_deleted": false,
            "representative_text": "pretend that no concurrency is happening: serializable isolation means that the database\nguarantees that transactions have the same effect as if they ran serially (i.e., one at a time,\nwithout any concurrency).\n\n",
            "selected_text": "serializable isolation means that the database\nguarantees that transactions have the same effect as if they ran serially (i.e., one at a time,\nwithout any concurrency).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1084,
            "is_deleted": false,
            "representative_text": "Concurrency bugs are hard to find by testing, because such bugs are only triggered when you get\nunlucky with the timing. Such timing issues might occur very rarely, and are usually difficult to\nreproduce. ",
            "selected_text": "Concurrency bugs are hard to find by testing, because such bugs are only triggered when you get\nunlucky with the timing. Such timing issues might occur very rarely, and are usually difficult to\nreproduce",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1085,
            "is_deleted": false,
            "representative_text": "When writing to the database, you will only overwrite data that has been committed (no dirty\nwrites).\n\n\n\n\n",
            "selected_text": "When writing to the database, you will only overwrite data that has been committed (no dirty\nwrites).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1086,
            "is_deleted": false,
            "representative_text": "If an error occurs halfway through a sequence of writes, the transaction should be aborted, and\nthe writes made up to that point should be discarded. ",
            "selected_text": "If an error occurs halfway through a sequence of writes, the transaction should be aborted, and\nthe writes made up to that point should be discarded",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1087,
            "is_deleted": false,
            "representative_text": "prevent dirty reads using the approach illustrated in Figure\u00a07-4: for every\nobject that is written, the database remembers both the old committed value and the new value\nset by the transaction that currently holds the write lock. While the transaction is ongoing, any\nother transactions that read the object are simply given the old value. ",
            "selected_text": "for every\nobject that is written, the database remembers both the old committed value and the new value\nset by the transaction that currently holds the write lock. While the transaction is ongoing, any\nother transactions that read the object are simply given the old value.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1088,
            "is_deleted": false,
            "representative_text": "Rather, ACID atomicity describes what happens if a client wants to make several writes, but a fault\noccurs after some of the writes have been processed\u2014for example, a process crashes, a network\nconnection is interrupted, a disk becomes full, or some integrity constraint is violated.\n",
            "selected_text": "ACID atomicity describes what happens if a client wants to make several writes, but a fault\noccurs after some of the writes have been processed",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1089,
            "is_deleted": false,
            "representative_text": "Only one transaction can hold the\nlock for any given object; if another transaction wants to write to the same object, it must wait\nuntil the first transaction is committed or aborted before it can acquire the lock and continue.\nThis locking is done automatically by databases in read committed mode (or stronger isolation\nlevels).\n\n",
            "selected_text": "Only one transaction can hold the\nlock for any given object; if another transaction wants to write to the same object, it must wait\nuntil the first transaction is committed or aborted before it can acquire the lock and continue.\nThis locking is done automatically by databases in read committed mode (or stronger isolation\nlevels).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1090,
            "is_deleted": false,
            "representative_text": "A\ntransaction is a way for an application to group several reads and writes together into a logical\nunit. Conceptually, all the reads and writes in a transaction are executed as one operation: either\nthe entire transaction succeeds (commit) or it fails (abort, rollback). If it fails, the\napplication can safely retry. ",
            "selected_text": "A\ntransaction is a way for an application to group several reads and writes together into a logical\nunit. Conceptually, all the reads and writes in a transaction are executed as one operation: either\nthe entire transaction succeeds (commit) or it fails (abort, rollback). If it fails, the\napplication can safely retry",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1091,
            "is_deleted": false,
            "representative_text": "having to worry about partial failure, by giving an all-or-nothing guarantee.\n\n",
            "selected_text": "all-or-nothing guarantee.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1092,
            "is_deleted": false,
            "representative_text": "(Systems that do not meet the ACID criteria are sometimes called BASE, which stands for\nBasically Available, Soft state, and Eventual consistency\n[9].\nThis is even more vague than the definition of ACID. It seems that the only sensible definition of\nBASE is \u201cnot ACID\u201d; i.e., it can mean almost anything you want.)\n\n",
            "selected_text": "Systems that do not meet the ACID criteria are sometimes called BASE, which stands for\nBasically Available, Soft state, and Eventual consistency\n[9].\nThis is even more vague than the definition of ACID. It seems that the only sensible definition of\nBASE is \u201cnot ACID\u201d; i.e., it can mean almost anything you want.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1094,
            "is_deleted": false,
            "representative_text": "Rather than blindly relying on tools, we need to develop a good understanding of the kinds of\nconcurrency problems that exist, and how to prevent them. Then we can build applications that are\nreliable and correct, using the tools at our disposal.\n\n",
            "selected_text": "Rather than blindly relying on tools, we need to develop a good understanding of the kinds of\nconcurrency problems that exist, and how to prevent them. Then we can build applications that are\nreliable and correct, using the tools at our disposal.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1096,
            "is_deleted": false,
            "representative_text": "Concurrently running transactions shouldn\u2019t interfere with each other. ",
            "selected_text": "Concurrently running transactions shouldn\u2019t interfere with each other.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1098,
            "is_deleted": false,
            "representative_text": "The safety guarantees provided by transactions are often described by the well-known acronym ACID,\nwhich stands for Atomicity, Consistency, Isolation, and Durability. ",
            "selected_text": "The safety guarantees provided by transactions are often described by the well-known acronym ACID,\nwhich stands for Atomicity, Consistency, Isolation, and Durability",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1101,
            "is_deleted": false,
            "representative_text": "concurrently\u2014in other words, the database prevents all possible race conditions.\n\n",
            "selected_text": "the database prevents all possible race conditions.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1102,
            "is_deleted": false,
            "representative_text": "In the previous sections we saw dirty writes and lost updates, two kinds of race conditions that\ncan occur when different transactions concurrently try to write to the same objects. ",
            "selected_text": "dirty writes and lost updates, two kinds of race conditions that\ncan occur when different transactions concurrently try to write to the same objects.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1103,
            "is_deleted": false,
            "representative_text": "Write skew can occur if two\ntransactions read the same objects, and then update some of those objects (different transactions\nmay update different objects). ",
            "selected_text": "Write skew can occur if two\ntransactions read the same objects, and then update some of those objects",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1105,
            "is_deleted": false,
            "representative_text": "Then the application can perform a read-modify-write cycle, and if any other\ntransaction tries to concurrently read the same object, it is forced to wait until the first\nread-modify-write cycle has completed.\n\n",
            "selected_text": "if any other\ntransaction tries to concurrently read the same object, it is forced to wait until the first\nread-modify-write cycle has completed.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1111,
            "is_deleted": false,
            "representative_text": "Serializable isolation is usually regarded as the strongest isolation level. It guarantees that even\nthough transactions may execute in parallel, the end result is the same as if they had executed one\nat a time, serially, without any concurrency. ",
            "selected_text": "Serializable isolation is usually regarded as the strongest isolation level. It guarantees that even\nthough transactions may execute in parallel, the end result is the same as if they had executed one\nat a time, serially, without any concurrency",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1115,
            "is_deleted": false,
            "representative_text": "An alternative is to allow them to execute in parallel and, if the\ntransaction manager detects a lost update, abort the transaction and force it to retry\nits read-modify-write cycle.\n\n\n\n\n\n",
            "selected_text": "An alternative is to allow them to execute in parallel and, if the\ntransaction manager detects a lost update, abort the transaction and force it to retry\nits read-modify-write cycle.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1117,
            "is_deleted": false,
            "representative_text": "If the current value does not match what you previously read, the update has no effect, and\nthe read-modify-write cycle must be retried.\n\n",
            "selected_text": "If the current value does not match what you previously read, the update has no effect, and\nthe read-modify-write cycle must be retried.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1118,
            "is_deleted": false,
            "representative_text": "avoid lost updates by allowing an update to happen only if the value has not changed since you last\nread it. ",
            "selected_text": "by allowing an update to happen only if the value has not changed since you last\nread it",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1120,
            "is_deleted": false,
            "representative_text": "An advantage of this approach is that databases can perform this check efficiently in conjunction\nwith snapshot isolation. ",
            "selected_text": "An advantage of this approach is that databases can perform this check efficiently in conjunction\nwith snapshot isolation",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1128,
            "is_deleted": false,
            "representative_text": "isn\u2019t used to store information about the booking\u2014it\u2019s purely a collection of locks which is used\nto prevent bookings on the same room and time range from being modified concurrently.\n\n\n",
            "selected_text": "purely a collection of locks which is used\nto prevent bookings on the same room and time range from being modified concurrently",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1129,
            "is_deleted": false,
            "representative_text": "The lost update problem can occur if an application reads some value from the database, modifies it,\nand writes back the modified value (a read-modify-write cycle). If two transactions do this\nconcurrently, one of the modifications can be lost, because the second write does not include the\nfirst modification. ",
            "selected_text": "The lost update problem can occur if an application reads some value from the database, modifies it,\nand writes back the modified value (a read-modify-write cycle). If two transactions do this\nconcurrently, one of the modifications can be lost, because the second write does not include the\nfirst modification",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1130,
            "is_deleted": false,
            "representative_text": "If you can\u2019t use a serializable isolation level, the second-best option in this case is probably\nto explicitly lock the rows that the transaction depends on. ",
            "selected_text": "the second-best option in this case is probably\nto explicitly lock the rows that the transaction depends on",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1132,
            "is_deleted": false,
            "representative_text": "This approach is called materializing conflicts, because it takes a phantom and turns it into a\nlock conflict on a concrete set of rows that exist in the database\n[11]. ",
            "selected_text": "This approach is called materializing conflicts, because it takes a phantom and turns it into a\nlock conflict on a concrete set of rows that exist in the database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1135,
            "is_deleted": false,
            "representative_text": "error-prone to figure out how to materialize conflicts, and it\u2019s ugly to let a concurrency control\nmechanism leak into the application data model. For those reasons, materializing conflicts should be\nconsidered a last resort if no alternative is possible. ",
            "selected_text": "it\u2019s ugly to let a concurrency control\nmechanism leak into the application data model. For those reasons, materializing conflicts should be\nconsidered a last resort if no alternative is possible",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1138,
            "is_deleted": false,
            "representative_text": "Another option is to simply force all atomic operations to be executed on a single thread.\n\n\n",
            "selected_text": "Another option is to simply force all atomic operations to be executed on a single thread.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1144,
            "is_deleted": false,
            "representative_text": "This effect, where a write in one transaction changes the result of a search query in another\ntransaction, is called a phantom [3].\n",
            "selected_text": "This effect, where a write in one transaction changes the result of a search query in another\ntransaction, is called a phantom",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1147,
            "is_deleted": false,
            "representative_text": "Instead, as discussed in \u201cDetecting Concurrent Writes\u201d, a common approach in such replicated\ndatabases is to allow concurrent writes to create several conflicting versions of a value (also\nknown as siblings), and to use application code or special data structures to resolve and merge\nthese versions after the fact.\n\n\n\n\n",
            "selected_text": "a common approach in such replicated\ndatabases is to allow concurrent writes to create several conflicting versions of a value (also\nknown as siblings), and to use application code or special data structures to resolve and merge\nthese versions after the fact.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1148,
            "is_deleted": false,
            "representative_text": "Note that the additional table\nisn\u2019t used to store information about the booking\u2014it\u2019s purely a collection of locks which is used\nto prevent bookings on the same room and time range from being modified concurrently.\n\n\n",
            "selected_text": "Note that the additional table\nisn\u2019t used to store information about the booking\u2014it\u2019s",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1149,
            "is_deleted": false,
            "representative_text": "The simplest way of avoiding concurrency problems is to remove the concurrency entirely: to\nexecute only one transaction at a time, in serial order, on a single thread. By doing so, we completely\nsidestep the problem of detecting and preventing conflicts between transactions: the resulting\nisolation is by definition serializable.\n\n",
            "selected_text": "to\nexecute only one transaction at a time, in serial order, on a single thread. By doing so, we completely\nsidestep the problem of detecting and preventing conflicts between transactions: the resulting\nisolation is by definition serializable.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1150,
            "is_deleted": false,
            "representative_text": "Snapshot isolation is a boon for long-running, read-only queries such as backups and analytics. It\nis very hard to reason about the meaning of a query if the data on which it operates is changing at\nthe same time as the query is executing. When a transaction can see a consistent snapshot of the\ndatabase, frozen at a particular point in time, it is much easier to understand.\n\n\n\n\n\n",
            "selected_text": "Snapshot isolation is a boon for long-running, read-only queries such as backups and analytics. It\nis very hard to reason about the meaning of a query if the data on which it operates is changing at\nthe same time as the query is executing. When a transaction can see a consistent snapshot of the\ndatabase, frozen at a particular point in time, it is much easier to understand.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1151,
            "is_deleted": false,
            "representative_text": "Atomic operations are usually implemented by taking an exclusive lock on the object when it is read\nso that no other transaction can read it until the update has been applied. ",
            "selected_text": "Atomic operations are usually implemented by taking an exclusive lock on the object when it is read\nso that no other transaction can read it until the update has been applied",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1167,
            "is_deleted": false,
            "representative_text": "The blocking of readers and writers is implemented by a having a lock on each object in the\ndatabase. The lock can either be in shared mode or in exclusive mode. The lock is used as\nfollows:\n\n\n\n\n",
            "selected_text": "The blocking of readers and writers is implemented by a having a lock on each object in the\ndatabase. The lock can either be in shared mode or in exclusive mode. The lock is used as\nfollows:",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1169,
            "is_deleted": false,
            "representative_text": "It\nmay take just one slow transaction, or one transaction that accesses a lot of data and acquires many\nlocks, to cause the rest of the system to grind to a halt. This instability is problematic when\nrobust operation is required.\n\n",
            "selected_text": "It\nmay take just one slow transaction, or one transaction that accesses a lot of data and acquires many\nlocks, to cause the rest of the system to grind to a halt. This instability is problematic when\nrobust operation is required",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1170,
            "is_deleted": false,
            "representative_text": "For this reason, systems with single-threaded serial transaction processing don\u2019t allow interactive\nmulti-statement transactions. Instead, the application must submit the entire transaction code to\nthe database ahead of time, as a stored procedure. ",
            "selected_text": "systems with single-threaded serial transaction processing don\u2019t allow interactive\nmulti-statement transactions. Instead, the application must submit the entire transaction code to\nthe database ahead of time, as a stored procedure",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1171,
            "is_deleted": false,
            "representative_text": "Since so many locks are in use, it can happen quite easily that transaction A is stuck waiting for\ntransaction B to release its lock, and vice versa. This situation is called deadlock. The database\nautomatically detects deadlocks between transactions and aborts one of them so that the others can\nmake progress. The aborted transaction needs to be retried by the application.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "Since so many locks are in use, it can happen quite easily that transaction A is stuck waiting for\ntransaction B to release its lock, and vice versa. This situation is called deadlock. The database\nautomatically detects deadlocks between transactions and aborts one of them so that the others can\nmake progress. The aborted transaction needs to be retried by the application.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1175,
            "is_deleted": false,
            "representative_text": "Snapshot isolation has the mantra readers never block writers, and writers never block\nreaders (see \u201cImplementing snapshot isolation\u201d), which captures this key difference between\nsnapshot isolation and two-phase locking. ",
            "selected_text": "Snapshot isolation has the mantra readers never block writers, and writers never block\nreaders",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1177,
            "is_deleted": false,
            "representative_text": "This is where the name \u201ctwo-phase\u201d comes from: the first phase\n(while the transaction is executing) is when the locks are acquired, and the second phase (at the\nend of the transaction) is when all the locks are released.\n\n\n\n\n\n",
            "selected_text": "This is where the name \u201ctwo-phase\u201d comes from: the first phase\n(while the transaction is executing) is when the locks are acquired, and the second phase (at the\nend of the transaction) is when all the locks are released.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1179,
            "is_deleted": false,
            "representative_text": "\n\u201cPhantoms causing write skew\u201d we discussed the problem of phantoms\u2014that is, one transaction\nchanging the results of another transaction\u2019s search query. ",
            "selected_text": "phantoms\u2014that is, one transaction\nchanging the results of another transaction\u2019s search query",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1180,
            "is_deleted": false,
            "representative_text": "Executing all transactions serially makes concurrency control much simpler, but limits the\ntransaction throughput of the database to the speed of a single CPU core on a single machine.\nRead-only transactions may execute elsewhere, using snapshot isolation, but for applications with\nhigh write throughput, the single-threaded transaction processor can become a serious bottleneck.\n\n\n",
            "selected_text": "Executing all transactions serially makes concurrency control much simpler, but limits the\ntransaction throughput of the database to the speed of a single CPU core on a single machine.\nRead-only transactions may execute elsewhere, using snapshot isolation, but for applications with\nhigh write throughput, the single-threaded transaction processor can become a serious bottleneck",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1181,
            "is_deleted": false,
            "representative_text": "Several transactions\nare allowed to concurrently read the same object as long as nobody is writing to it. But as soon as\nanyone wants to write (modify or delete) an object, exclusive access is required:\n\n\n\n",
            "selected_text": "Several transactions\nare allowed to concurrently read the same object as long as nobody is writing to it. But as soon as\nanyone wants to write (modify or delete) an object, exclusive access is required:",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1182,
            "is_deleted": false,
            "representative_text": "A new HTTP request starts a new transaction.\n\n",
            "selected_text": "A new HTTP request starts a new transaction.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1183,
            "is_deleted": false,
            "representative_text": "it protects against all the race conditions discussed earlier, including lost updates and write skew.\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "it protects against all the race conditions discussed earlier, including lost updates and write skew.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1185,
            "is_deleted": false,
            "representative_text": "In 2PL, writers don\u2019t just block other writers; they also block readers and vice\nversa. ",
            "selected_text": "In 2PL, writers don\u2019t just block other writers; they also block readers and vice\nversa",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1186,
            "is_deleted": false,
            "representative_text": "1970s, is performance: transaction throughput and response times of queries are significantly worse\nunder two-phase locking than under weak isolation.\n\n",
            "selected_text": "transaction throughput and response times of queries are significantly worse\nunder two-phase locking than under weak isolation.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1189,
            "is_deleted": false,
            "representative_text": "If one node\nfails, a common solution is to simply stop the entire cluster workload. After the faulty node is\nrepaired, the computation is restarted from the last checkpoint\n[7,\n8].\nThus, a supercomputer is more like a single-node computer than a distributed system: it deals with\npartial failure by letting it escalate into total failure\u2014if any part of the system fails, just\nlet everything crash (like a kernel panic on a single machine).\n\n\n",
            "selected_text": "If one node\nfails, a common solution is to simply stop the entire cluster workload. After the faulty node is\nrepaired, the computation is restarted from the last checkpoint\n[7,\n8].\nThus, a supercomputer is more like a single-node computer than a distributed system",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1191,
            "is_deleted": false,
            "representative_text": "A long timeout means a long wait until a node is declared dead (and during this time, users may have\nto wait or see error messages). A short timeout detects faults faster, but carries a higher risk of\nincorrectly declaring a node dead when in fact it has only suffered a temporary slowdown (e.g., due\nto a load spike on the node or the network).\n\n",
            "selected_text": "A long timeout means a long wait until a node is declared dead (and during this time, users may have\nto wait or see error messages). A short timeout detects faults faster, but carries a higher risk of\nincorrectly declaring a node dead when in fact it has only suffered a temporary slowdown",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1194,
            "is_deleted": false,
            "representative_text": "Serial execution is, in a sense, pessimistic to the extreme: it is essentially equivalent to each\ntransaction having an exclusive lock on the entire database (or one partition of the database) for\nthe duration of the transaction. We compensate for the pessimism by making each transaction very\nfast to execute, so it only needs to hold the \u201clock\u201d for a short time.\n\n\n\n",
            "selected_text": "Serial execution is, in a sense, pessimistic to the extreme: it is essentially equivalent to each\ntransaction having an exclusive lock on the entire database (or one partition of the database) for\nthe duration of the transaction. We compensate for the pessimism by making each transaction very\nfast to execute, so it only needs to hold the \u201clock\u201d for a short time.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1195,
            "is_deleted": false,
            "representative_text": "If the database\nkeeps track of each transaction\u2019s activity in great detail, it can be precise about which\ntransactions need to abort, but the bookkeeping overhead can become significant. Less detailed\ntracking is faster, but may lead to more transactions being aborted than strictly necessary.\n\n",
            "selected_text": "If the database\nkeeps track of each transaction\u2019s activity in great detail, it can be precise about which\ntransactions need to abort, but the bookkeeping overhead can become significant. Less detailed\ntracking is faster, but may lead to more transactions being aborted than strictly necessary.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1197,
            "is_deleted": false,
            "representative_text": "For that reason, most databases with 2PL\nactually implement index-range locking (also known as next-key locking), which is a simplified\napproximation of predicate locking [41,\n50].\n\n",
            "selected_text": "most databases with 2PL\nactually implement index-range locking (also known as next-key locking), which is a simplified\napproximation of predicate locking",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1198,
            "is_deleted": false,
            "representative_text": "The fault handling must be part of the software design, and\nyou (as operator of the software) need to know what behavior to expect from the software in the case\nof a fault.\n\n",
            "selected_text": "The fault handling must be part of the software design, and\nyou (as operator of the software) need to know what behavior to expect from the software in the case\nof a fault.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1199,
            "is_deleted": false,
            "representative_text": "UDP is a good choice in situations where delayed data is worthless. ",
            "selected_text": "UDP is a good choice in situations where delayed data is worthless",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1200,
            "is_deleted": false,
            "representative_text": "However, if there is enough spare capacity, and if contention between transactions is not too high,\noptimistic concurrency control techniques tend to perform better than pessimistic ones. ",
            "selected_text": "there is enough spare capacity, and if contention between transactions is not too high,\noptimistic concurrency control techniques tend to perform better than pessimistic ones",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1201,
            "is_deleted": false,
            "representative_text": "By avoiding unnecessary aborts, SSI preserves snapshot\nisolation\u2019s support for long-running reads from a consistent snapshot.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "By avoiding unnecessary aborts, SSI preserves snapshot\nisolation\u2019s support for long-running reads from a consistent snapshot.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1202,
            "is_deleted": false,
            "representative_text": "When one part of the network is cut off from the rest due to a network fault, that is sometimes\ncalled a network partition or netsplit. ",
            "selected_text": "When one part of the network is cut off from the rest due to a network fault, that is sometimes\ncalled a network partition or netsplit",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1203,
            "is_deleted": false,
            "representative_text": "Shared-nothing is not the only way of building systems, but it has become the dominant approach for\nbuilding internet services, for several reasons: it\u2019s comparatively cheap because it\nrequires no special hardware, it can make use of commoditized cloud computing services, and it can\nachieve high reliability through redundancy across multiple geographically distributed datacenters.\n\n\n\n",
            "selected_text": "Shared-nothing is not the only way of building systems, but it has become the dominant approach for\nbuilding internet services, for several reasons: it\u2019s comparatively cheap because it\nrequires no special hardware, it can make use of commoditized cloud computing services, and it can\nachieve high reliability through redundancy across multiple geographically distributed datacenters",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1208,
            "is_deleted": false,
            "representative_text": "Why not abort transaction 43 immediately when the stale read is detected?\nWell, if transaction 43 was a read-only transaction, it wouldn\u2019t need to be aborted, because there\nis no risk of write skew. ",
            "selected_text": "Why not abort transaction 43 immediately when the stale read is detected?\nWell, if transaction 43 was a read-only transaction, it wouldn\u2019t need to be aborted, because there\nis no risk of write skew",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1209,
            "is_deleted": false,
            "representative_text": "This chapter has painted a bleak picture of concurrency control in databases. On the one hand, we\nhave implementations of serializability that don\u2019t perform well (two-phase locking) or don\u2019t scale\nwell (serial execution). On the other hand, we have weak isolation levels that have good\nperformance, but are prone to various race conditions (lost updates, write skew, phantoms, etc.). ",
            "selected_text": " On the one hand, we\nhave implementations of serializability that don\u2019t perform well (two-phase locking) or don\u2019t scale\nwell (serial execution). On the other hand, we have weak isolation levels that have good\nperformance, but are prone to various race conditions (lost updates, write skew, phantoms, etc.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1212,
            "is_deleted": false,
            "representative_text": "When a\ntransaction wants to commit, the database checks whether anything bad happened (i.e., whether\nisolation was violated); if so, the transaction is aborted and has to be retried. Only transactions\nthat executed serializably are allowed to commit.\n\n",
            "selected_text": "When a\ntransaction wants to commit, the database checks whether anything bad happened (i.e., whether\nisolation was violated); if so, the transaction is aborted and has to be retried. Only transactions\nthat executed serializably are allowed to commit.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1213,
            "is_deleted": false,
            "representative_text": "In particular, read-only queries can run on a consistent\nsnapshot without requiring any locks, which is very appealing for read-heavy workloads.\n\n\n\n",
            "selected_text": "read-only queries can run on a consistent\nsnapshot without requiring any locks, which is very appealing for read-heavy workloads.",
            "color": "yellow",
            "note": "Readers don\u2019t block writers",
            "chapter": null
        },
        {
            "id": 1217,
            "is_deleted": false,
            "representative_text": "(As discussed in \u201cReliability\u201d, there is no\nsuch thing as perfect reliability, so we\u2019ll need to understand the limits of what we can\nrealistically promise.)\n\n",
            "selected_text": "there is no\nsuch thing as perfect reliability",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1218,
            "is_deleted": false,
            "representative_text": "Dirty reads\n\nOne client reads another client\u2019s writes before they have been committed. The read committed\nisolation level and stronger levels prevent dirty reads.\n\nDirty writes\n\nOne client overwrites data that another client has written, but not yet committed. Almost all\ntransaction implementations prevent dirty writes.\n\nRead skew (nonrepeatable reads)\n\n\n\n\nA client sees different parts of the database at different points in time. This issue is most\ncommonly prevented with snapshot isolation, which allows a transaction to read from a consistent\nsnapshot at one point in time. It is usually implemented with multi-version concurrency control\n(MVCC).\n\nLost updates\n\nTwo clients concurrently perform a read-modify-write cycle. One overwrites the other\u2019s write\nwithout incorporating its changes, so data is lost. Some implementations of snapshot isolation\nprevent this anomaly automatically, while others require a manual lock (SELECT FOR UPDATE).\n\nWrite skew\n\nA transaction reads something, makes a decision based on the value it saw, and writes the decision\nto the database. However, by the time the write is made, the premise of the decision is no longer\ntrue. Only serializable isolation prevents this anomaly.\n\nPhantom reads\n\nA transaction reads objects that match some search condition. Another client makes a write that\naffects the results of that search. Snapshot isolation prevents straightforward phantom reads, but\nphantoms in the context of write skew require special treatment, such as index-range locks.\n\n\n\nWeak isolation levels protect against some of those anomalies but leave you, the application\ndeveloper, to handle others manually (e.g., using explicit locking). Only serializable isolation\nprotects against all of these issues. We discussed three different approaches to implementing\nserializable transactions:\n\nLiterally executing transactions in a serial order\n\nIf you can make each transaction very fast to execute, and the transaction throughput is low\nenough to process on a single CPU core, this is a simple and effective option.\n\nTwo-phase locking\n\nFor decades this has been the standard way of implementing serializability, but many applications\navoid using it because of its performance characteristics.\n\nSerializable snapshot isolation (SSI)\n\nA fairly new algorithm that avoids most of the downsides of the previous approaches. It uses an\noptimistic approach, allowing transactions to proceed without blocking. When a transaction wants\nto commit, it is checked, and it is aborted if the execution was not serializable.\n\n\n\n",
            "selected_text": "Dirty reads\n\nOne client reads another client\u2019s writes before they have been committed. The read committed\nisolation level and stronger levels prevent dirty reads.\n\nDirty writes\n\nOne client overwrites data that another client has written, but not yet committed. Almost all\ntransaction implementations prevent dirty writes.\n\nRead skew (nonrepeatable reads)\n\n\n\n\nA client sees different parts of the database at different points in time. This issue is most\ncommonly prevented with snapshot isolation, which allows a transaction to read from a consistent\nsnapshot at one point in time. It is usually implemented with multi-version concurrency control\n(MVCC).\n\nLost updates\n\nTwo clients concurrently perform a read-modify-write cycle. One overwrites the other\u2019s write\nwithout incorporating its changes, so data is lost. Some implementations of snapshot isolation\nprevent this anomaly automatically, while others require a manual lock (SELECT FOR UPDATE).\n\nWrite skew\n\nA transaction reads something, makes a decision based on the value it saw, and writes the decision\nto the database. However, by the time the write is made, the premise of the decision is no longer\ntrue. Only serializable isolation prevents this anomaly.\n\nPhantom reads\n\nA transaction reads objects that match some search condition. Another client makes a write that\naffects the results of that search. Snapshot isolation prevents straightforward phantom reads, but\nphantoms in the context of write skew require special treatment, such as index-range locks.\n\n\n\nWeak isolation levels protect against some of those anomalies but leave you, the application\ndeveloper, to handle others manually (e.g., using explicit locking). Only serializable isolation\nprotects against all of these issues. We discussed three different approaches to implementing\nserializable transactions:\n\nLiterally executing transactions in a serial order\n\nIf you can make each transaction very fast to execute, and the transaction throughput is low\nenough to process on a single CPU core, this is a simple and effective option.\n\nTwo-phase locking\n\nFor decades this has been the standard way of implementing serializability, but many applications\navoid using it because of its performance characteristics.\n\nSerializable snapshot isolation (SSI)\n\nA fairly new algorithm that avoids most of the downsides of the previous approaches. It uses an\noptimistic approach, allowing transactions to proceed without blocking. When a transaction wants\nto commit, it is checked, and it is aborted if the execution was not serializable.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1222,
            "is_deleted": false,
            "representative_text": "By contrast, serializable snapshot isolation is an optimistic concurrency control technique.\nOptimistic in this context means that instead of blocking if something potentially dangerous\nhappens, transactions continue anyway, in the hope that everything will turn out all right. ",
            "selected_text": "By contrast, serializable snapshot isolation is an optimistic concurrency control technique.\nOptimistic in this context means that instead of blocking if something potentially dangerous\nhappens, transactions continue anyway, in the hope that everything will turn out all right",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1224,
            "is_deleted": false,
            "representative_text": "The usual way of handling this issue is a timeout: after some time you give up waiting and assume that\nthe response is not going to arrive. ",
            "selected_text": "The usual way of handling this issue is a timeout: after some time you give up waiting and assume that\nthe response is not going to arrive",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1225,
            "is_deleted": false,
            "representative_text": "principle that if anything might possibly go wrong (as indicated by a lock held by another\ntransaction), it\u2019s better to wait until the situation is safe again before doing anything. It is\nlike mutual exclusion, which is used to protect data structures in multi-threaded programming.\n\n",
            "selected_text": "if anything might possibly go wrong (as indicated by a lock held by another\ntransaction), it\u2019s better to wait until the situation is safe again before doing anything. It is\nlike mutual exclusion, which is used to protect data structures in multi-threaded programming",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1226,
            "is_deleted": false,
            "representative_text": "This nondeterminism and possibility of partial failures is what makes distributed systems hard to\nwork with [5].\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "This nondeterminism and possibility of partial failures is what makes distributed systems hard to\nwork with",
            "color": "yellow",
            "note": "A single system either fails fully or succeeds completely. But at disturbed system can fail partially",
            "chapter": null
        },
        {
            "id": 1229,
            "is_deleted": false,
            "representative_text": "snapshot isolation, SSI adds an algorithm for detecting serialization conflicts among writes and\ndetermining which transactions to abort.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "SSI adds an algorithm for detecting serialization conflicts among writes and\ndetermining which transactions to abort",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1231,
            "is_deleted": false,
            "representative_text": "interruption in the sound) and move on in the stream. The retry happens at the human layer instead.\n(\u201cCould you repeat that please? The sound just cut out for a moment.\u201d)\n\n\n",
            "selected_text": " The retry happens at the human layer instead.\n(\u201cCould you repeat that please? The sound just cut out for a moment.\u201d)",
            "color": "yellow",
            "note": "lol",
            "chapter": null
        },
        {
            "id": 1244,
            "is_deleted": false,
            "representative_text": "it is in, because problems in the network cannot reliably be distinguished from problems at a node.\n\n",
            "selected_text": "problems in the network cannot reliably be distinguished from problems at a node.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1246,
            "is_deleted": false,
            "representative_text": "The difference between the two values tells you how much time\nelapsed between the two checks. ",
            "selected_text": "The difference between the two values tells you how much time\nelapsed between the two checks",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1250,
            "is_deleted": false,
            "representative_text": "(e.g., due to a network interruption or GC pause), it may have been demoted and another leader may\nhave already been elected.\n\n\n\n",
            "selected_text": "due to a network interruption or GC pause",
            "color": "yellow",
            "note": "Reasons a node could be declared dead",
            "chapter": null
        },
        {
            "id": 1252,
            "is_deleted": false,
            "representative_text": "Checking a token on the server side may seem like a downside, but it is arguably a good thing: it is\nunwise for a service to assume that its clients will always be well behaved, because the clients are\noften run by people whose priorities are very different from the priorities of the people running\nthe service [76]. ",
            "selected_text": "it is\nunwise for a service to assume that its clients will always be well behaved, because the clients are\noften run by people whose priorities are very different from the priorities of the people running\nthe service",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1254,
            "is_deleted": false,
            "representative_text": "epoch: midnight UTC on January 1, 1970, according to the Gregorian calendar, not counting leap\nseconds. ",
            "selected_text": "epoch: midnight UTC on January 1, 1970",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1255,
            "is_deleted": false,
            "representative_text": "That includes decisions about declaring nodes dead. If a quorum of nodes declares another node\ndead, then it must be considered dead, even if that node still very much feels alive. The individual\nnode must abide by the quorum decision and step down.\n\n",
            "selected_text": "That includes decisions about declaring nodes dead. If a quorum of nodes declares another node\ndead, then it must be considered dead, even if that node still very much feels alive. The individual\nnode must abide by the quorum decision and step down",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1259,
            "is_deleted": false,
            "representative_text": "A system is Byzantine fault-tolerant if it continues to operate correctly even if some of the\nnodes are malfunctioning and not obeying the protocol, or if malicious attackers are interfering\nwith the network. ",
            "selected_text": "A system is Byzantine fault-tolerant if it continues to operate correctly even if some of the\nnodes are malfunctioning and not obeying the protocol, or if malicious attackers are interfering\nwith the network",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1262,
            "is_deleted": false,
            "representative_text": "However, with liveness properties we are allowed to make caveats: for example, we could say that a\nrequest needs to receive a response only if a majority of nodes have not crashed, and only if the\nnetwork eventually recovers from an outage. ",
            "selected_text": "However, with liveness properties we are allowed to make caveats: for example, we could say that a\nrequest needs to receive a response only if a majority of nodes have not crashed, and only if the\nnetwork eventually recovers from an outage",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1267,
            "is_deleted": false,
            "representative_text": "requires that eventually the system returns to a synchronous state\u2014that is, any period of network\ninterruption lasts only for a finite duration and is then repaired.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "selected_text": "that is, any period of network\ninterruption lasts only for a finite duration and is then repaired",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1268,
            "is_deleted": false,
            "representative_text": "This is a realistic model of many\nsystems: most of the time, networks and processes are quite well behaved\u2014otherwise we would never\nbe able to get anything done\u2014but we have to reckon with the fact that any timing assumptions\nmay be shattered occasionally. ",
            "selected_text": "This is a realistic model of many\nsystems: most of the time, networks and processes are quite well behaved\u2014otherwise we would never\nbe able to get anything done\u2014but we have to reckon with the fact that any timing assumptions\nmay be shattered occasionally",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1270,
            "is_deleted": false,
            "representative_text": "For modeling real systems, the partially synchronous model with crash-recovery faults is generally\nthe most useful model. ",
            "selected_text": "For modeling real systems, the partially synchronous model with crash-recovery faults is generally\nthe most useful model",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1275,
            "is_deleted": false,
            "representative_text": "(And yes, you guessed it\u2014eventual consistency is a\nliveness property [89].)\n\n",
            "selected_text": "eventual consistency is a\nliveness property",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1278,
            "is_deleted": false,
            "representative_text": "Safety is often informally defined as nothing bad happens, and liveness as something good\neventually happens. ",
            "selected_text": "Safety is often informally defined as nothing bad happens, and liveness as something good\neventually happens",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1279,
            "is_deleted": false,
            "representative_text": "That is, even if all nodes crash, or\nthe entire network fails, the algorithm must nevertheless ensure that it does not return a wrong\nresult (i.e., that the safety properties remain satisfied).\n\n",
            "selected_text": "That is, even if all nodes crash, or\nthe entire network fails, the algorithm must nevertheless ensure that it does not return a wrong\nresult (i.e., that the safety properties remain satisfied",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1285,
            "is_deleted": false,
            "representative_text": "They don\u2019t come for free: systems with stronger guarantees may have worse performance or be less\nfault-tolerant than systems with weaker guarantees. ",
            "selected_text": "systems with stronger guarantees may have worse performance or be less\nfault-tolerant than systems with weaker guarantees",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1286,
            "is_deleted": false,
            "representative_text": "But while there is some overlap, they are mostly independent concerns: transaction isolation is\nprimarily about avoiding race conditions due to concurrently executing transactions, whereas\ndistributed consistency is mostly about coordinating the state of replicas in the face of delays and\nfaults.\n\n",
            "selected_text": "transaction isolation is\nprimarily about avoiding race conditions due to concurrently executing transactions, whereas\ndistributed consistency is mostly about coordinating the state of replicas in the face of delays and\nfaults.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1288,
            "is_deleted": false,
            "representative_text": "The simplest\nway of handling such faults is to simply let the entire service fail, and show the user an error\nmessage. ",
            "selected_text": "The simplest\nway of handling such faults is to simply let the entire service fail, and show the user an error\nmessage",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1289,
            "is_deleted": false,
            "representative_text": "But the basic idea is to make a system appear as if there were only one copy of the data,\nand all operations on it are atomic. ",
            "selected_text": "the basic idea is to make a system appear as if there were only one copy of the data,\nand all operations on it are atomic",
            "color": "yellow",
            "note": "Liberalizability",
            "chapter": null
        },
        {
            "id": 1290,
            "is_deleted": false,
            "representative_text": "This is because the customers with the slowest requests are often those who have\nthe most data on their accounts because they have made many purchases\u2014that is, they\u2019re the most\nvaluable customers\n[19].\nIt\u2019s important to keep those customers happy by ensuring the website is fast for them: Amazon has\nalso observed that a 100\u00a0ms increase in response time reduces sales by 1%\n[20],\nand others report that a 1-second slowdown reduces a customer satisfaction metric by 16%\n[21,\n22].\n\n",
            "selected_text": "This is because the customers with the slowest requests are often those who have\nthe most data on their accounts because they have made many purchases\u2014that is, they\u2019re the most\nvaluable customers\n[19].\nIt\u2019s important to keep those customers happy by ensuring the website is fast for them:",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1291,
            "is_deleted": false,
            "representative_text": "At times when the network is working correctly, a system can provide both consistency\n(linearizability) and total availability. When a network fault occurs, you have to choose between\neither linearizability or total availability. ",
            "selected_text": "At times when the network is working correctly, a system can provide both consistency\n(linearizability) and total availability. When a network fault occurs, you have to choose between\neither linearizability or total availability",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1292,
            "is_deleted": false,
            "representative_text": "In this case, when the resizer fetches the image (step 5), it might see an old version of\nthe image, or nothing at all. ",
            "selected_text": "In this case, when the resizer fetches the image (step 5), it might see an old version of\nthe image, or nothing at all",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1293,
            "is_deleted": false,
            "representative_text": "This requirement ensures the recency guarantee we\ndiscussed earlier: once a new value has been written or read, all subsequent reads see the value\nthat was written, until it is overwritten again.\n\n\n",
            "selected_text": "This requirement ensures the recency guarantee we\ndiscussed earlier: once a new value has been written or read, all subsequent reads see the value\nthat was written, until it is overwritten again",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1294,
            "is_deleted": false,
            "representative_text": "If your application requires linearizability, and some replicas are disconnected from the other\nreplicas due to a network problem, then some replicas cannot process requests while they are\ndisconnected: they must either wait until the network problem is fixed, or return an error (either\nway, they become unavailable).\n\n\nIf your application does not require linearizability, then it can be written in a way that each\nreplica can process requests independently, even if it is disconnected from other replicas (e.g.,\nmulti-leader). In this case, the application can remain available in the face of a network\nproblem, but its behavior is not linearizable.\n\n\n\n",
            "selected_text": "If your application requires linearizability, and some replicas are disconnected from the other\nreplicas due to a network problem, then some replicas cannot process requests while they are\ndisconnected: they must either wait until the network problem is fixed, or return an error (either\nway, they become unavailable).\n\n\nIf your application does not require linearizability, then it can be written in a way that each\nreplica can process requests independently, even if it is disconnected from other replicas (e.g.,\nmulti-leader). In this case, the application can remain available in the face of a network\nproblem, but its behavior is not linearizable.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1295,
            "is_deleted": false,
            "representative_text": "either Consistent or Available when Partitioned\n[39]. ",
            "selected_text": "either Consistent or Available when Partitioned",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1298,
            "is_deleted": false,
            "representative_text": "Linearizability is a recency guarantee on reads and writes of a register (an individual object).\nIt doesn\u2019t group operations together into transactions, so it does not prevent problems such as\nwrite skew (see \u201cWrite Skew and Phantoms\u201d), unless you take additional measures such as\nmaterializing conflicts (see \u201cMaterializing conflicts\u201d).\n\n\n\n\n\n\n",
            "selected_text": "Linearizability is a recency guarantee on reads and writes of a register (an individual object).\nIt doesn\u2019t group operations together into transactions, so it does not prevent problems such as\nwrite skew",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1299,
            "is_deleted": false,
            "representative_text": "The requirement of linearizability is that the lines joining up the operation markers always move\nforward in time (from left to right), never backward. ",
            "selected_text": "The requirement of linearizability is that the lines joining up the operation markers always move\nforward in time (from left to right), never backward",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1301,
            "is_deleted": false,
            "representative_text": "If the network between datacenters is interrupted in a single-leader setup, clients connected to\nfollower datacenters cannot contact the leader, so they cannot make any writes to the database, nor\nany linearizable reads. They can still make reads from the follower, but they might be stale\n(nonlinearizable). ",
            "selected_text": "If the network between datacenters is interrupted in a single-leader setup, clients connected to\nfollower datacenters cannot contact the leader, so they cannot make any writes to the database, nor\nany linearizable reads. They can still make reads from the follower, but they might be stale\n(nonlinearizable)",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1302,
            "is_deleted": false,
            "representative_text": "These constraints all require there to\nbe a single up-to-date value (the account balance, the stock level, the seat occupancy) that all\nnodes agree on.\n\n",
            "selected_text": "These constraints all require there to\nbe a single up-to-date value (the account balance, the stock level, the seat occupancy) that all\nnodes agree on.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1303,
            "is_deleted": false,
            "representative_text": "error), you need linearizability.\n\n\n",
            "selected_text": "you need linearizability.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1304,
            "is_deleted": false,
            "representative_text": "Thus, if one\nclient\u2019s read returns the new value 1, all subsequent reads must also return the new value, even if\nthe write operation has not yet completed.\n\n",
            "selected_text": "Thus, if one\nclient\u2019s read returns the new value 1, all subsequent reads must also return the new value, even if\nthe write operation has not yet completed.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1305,
            "is_deleted": false,
            "representative_text": "Systems with multi-leader replication are generally not linearizable, because they concurrently\nprocess writes on multiple nodes and asynchronously replicate them to other nodes. ",
            "selected_text": "Systems with multi-leader replication are generally not linearizable, because they concurrently\nprocess writes on multiple nodes and asynchronously replicate them to other nodes",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1307,
            "is_deleted": false,
            "representative_text": "Since linearizability essentially means \u201cbehave as though there is only a single copy of the data,\nand all operations on it are atomic,\u201d the simplest answer would be to really only use a single copy\nof the data. ",
            "selected_text": "linearizability essentially means \u201cbehave as though there is only a single copy of the data,\nand all operations on it are atomic",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1309,
            "is_deleted": false,
            "representative_text": "Serializability is an isolation property of transactions, where every transaction may read and\nwrite multiple objects (rows, documents, records)\u2014see \u201cSingle-Object and Multi-Object Operations\u201d. It\nguarantees that transactions behave the same as if they had executed in some serial order (each\ntransaction running to completion before the next transaction starts). ",
            "selected_text": "Serializability is an isolation property of transactions, where every transaction may read and\nwrite multiple objects (rows, documents, records)\u2014see \u201cSingle-Object and Multi-Object Operations\u201d. It\nguarantees that transactions behave the same as if they had executed in some serial order (each\ntransaction running to completion before the next transaction starts)",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1310,
            "is_deleted": false,
            "representative_text": "One way of electing a leader is to use a lock: every node that starts up\ntries to acquire the lock, and the one that succeeds becomes the leader\n[14]. No matter how this\nlock is implemented, it must be linearizable: all nodes must agree which node owns the lock;\notherwise it is useless.\n\n\n\n\n\n",
            "selected_text": "One way of electing a leader is to use a lock: every node that starts up\ntries to acquire the lock, and the one that succeeds becomes the leader\n[14]. No matter how this\nlock is implemented, it must be linearizable: all nodes must agree which node owns the lock;\notherwise it is useless.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1311,
            "is_deleted": false,
            "representative_text": "If you want to enforce this constraint as the data is written (such that if two people\ntry to concurrently create a user or a file with the same name, one of them will be returned an\nerror), you need linearizability.\n\n\n",
            "selected_text": "If you want to enforce this constraint as the data is written",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1312,
            "is_deleted": false,
            "representative_text": "images in the file storage become permanently inconsistent.\n\n",
            "selected_text": "storage become permanently inconsistent",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1315,
            "is_deleted": false,
            "representative_text": "It is\npossible (though computationally expensive) to test whether a system\u2019s behavior is linearizable by\nrecording the timings of all requests and responses, and checking whether they can be arranged into\na valid sequential order [11].\n\n\n",
            "selected_text": "It is\npossible (though computationally expensive) to test whether a system\u2019s behavior is linearizable by\nrecording the timings of all requests and responses, and checking whether they can be arranged into\na valid sequential order [11].",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1316,
            "is_deleted": false,
            "representative_text": "Thus, applications that don\u2019t require linearizability can be more tolerant of network problems. ",
            "selected_text": "Thus, applications that don\u2019t require linearizability can be more tolerant of network problems",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1317,
            "is_deleted": false,
            "representative_text": "Even though crashes, race conditions, and disk failures do occur, the transaction abstraction hides\nthose problems so that the application doesn\u2019t need to worry about them.\n\n\n",
            "selected_text": "Even though crashes, race conditions, and disk failures do occur, the transaction abstraction hides\nthose problems so that the application doesn\u2019t need to worry about them.",
            "color": "yellow",
            "note": null,
            "chapter": null
        }
    ]
}