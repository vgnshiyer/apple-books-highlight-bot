{
    "asset_id": "28AEDF62F12B289C88BD6659BD6E50CC",
    "title": "Designing Data-Intensive Applications",
    "author": "Kleppmann, Martin",
    "highlights": [
        {
            "id": 799,
            "is_deleted": false,
            "representative_text": "But what if many-to-many relationships are very common in your data? The relational model can handle simple cases of many-to-many relationships, but as the connections within your data become more complex, it becomes more natural to start modeling your data as a graph. ",
            "selected_text": "But what if many-to-many relationships are very common in your data? The relational model can handle simple cases of many-to-many relationships, but as the connections within your data become more complex, it becomes more natural to start modeling your data as a graph.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 801,
            "is_deleted": false,
            "representative_text": "Scalability is the term we use to describe a system's ability to cope with increased load. ",
            "selected_text": "Scalability is the term we use to describe a system's ability to cope with increased load",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 802,
            "is_deleted": false,
            "representative_text": "A need for greater scalability than relational databases can easily achieve, including very large datasets or very high write throughput ",
            "selected_text": "greater scalability than relational databases",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 803,
            "is_deleted": false,
            "representative_text": "There are plenty of well-known tree data structures that you can use, such as red-black trees or AVL trees [2]. With these data structures, you can insert keys in any order and read them back in sorted order. ",
            "selected_text": "There are plenty of well-known tree data structures that you can use, such as red-black trees or AVL trees [2]. With these data structures, you can insert keys in any order and read them back in sorted order.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 804,
            "is_deleted": false,
            "representative_text": "While distributing stateless services across multiple machines is fairly straightforward, taking stateful data systems from a single node to a distributed setup can introduce a lot of additional complexity. For this reason, common wisdom until recently was to keep your database on a single node (scale up) until scaling cost or high-availability requirements forced you to make it distributed. ",
            "selected_text": "While distributing stateless services across multiple machines is fairly straightforward, taking stateful data systems from a single node to a distributed setup can introduce a lot of additional complexity. For this reason, common wisdom until recently was to keep your database on a single node (scale up) until scaling cost or high-availability requirements forced you to make it distributed",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 805,
            "is_deleted": false,
            "representative_text": "A data warehouse, by contrast, is a separate database that analysts can query to their hearts' content, without affecting OLTP operations [48]. The data warehouse contains a read-only copy of the data in all the various OLTP systems in the company. Data is extracted from OLTP databases (using either a periodic data dump or a continuous stream of updates), transformed into an analysis-friendly schema, cleaned up, and then loaded into the data warehouse. This process of getting data into the warehouse is known as Extract-Transform-Load (ETL) and is illustrated in Figure 3-8. ",
            "selected_text": "A data warehouse, by contrast, is a separate database that analysts can query to their hearts' content, without affecting OLTP operations [48]. The data warehouse contains a read-only copy of the data in all the various OLTP systems in the company. Data is extracted from OLTP databases (using either a periodic data dump or a continuous stream of updates), transformed into an analysis-friendly schema, cleaned up, and then loaded into the data warehouse. This process of getting data into the warehouse is known as Extract-Transform-Load (ETL",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 806,
            "is_deleted": false,
            "representative_text": "In a web browser, using declarative CSS styling is much better than manipulating styles imperatively in JavaScript. Similarly, in databases, declarative query languages like SQL turned out to be much better than imperative query APIs.vi ",
            "selected_text": "In a web browser, using declarative CSS styling is much better than manipulating styles imperatively in JavaScript. Similarly, in databases, declarative query languages like SQL turned out to be much better than imperative query APIs",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 807,
            "is_deleted": false,
            "representative_text": "Document databases reverted back to the hierarchical model in one aspect: storing nested records (one-to-many relationships, like positions, education, and contact_info in Figure 2-1) within their parent record rather than in a separate table. ",
            "selected_text": "Document databases reverted back to the hierarchical model in one aspect: storing nested records",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 808,
            "is_deleted": false,
            "representative_text": "Table 3-1. Comparing characteristics of transaction processing versus analytic systems ",
            "selected_text": "Table 3-1. Comparing characteristics of transaction processing versus analytic systems",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 809,
            "is_deleted": false,
            "representative_text": "The document model has limitations: for example, you cannot refer directly to a nested item within a document, but instead you need to say something like \"the second item in the list of positions for user 251\" (much like an access path in the hierarchical model). ",
            "selected_text": "you cannot refer directly to a nested item",
            "color": "yellow",
            "note": "Cannot directly extra position of an employee. Need to go through the hierarchy until u reach the position node, so to speak ",
            "chapter": null
        },
        {
            "id": 810,
            "is_deleted": false,
            "representative_text": "Evolvability ",
            "selected_text": "Evolvability",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 811,
            "is_deleted": false,
            "representative_text": "In order to make the database resilient to crashes, it is common for B-tree implementations to include an additional data structure on disk: a write-ahead log (WAL, also known as a redo log). This is an append-only file to which every B-tree modification must be written before it can be applied to the pages of the tree itself. ",
            "selected_text": "B-tree implementations to include an additional data structure on disk: a write-ahead log (WAL, also known as a redo log). This is an append-only file to which every B-tree modification must be written before it can be applied to the pages of the tree itself",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 812,
            "is_deleted": false,
            "representative_text": "Analyzing whether people are more inclined to buy fresh fruit or candy, depending on the day of the week ",
            "selected_text": "Analyzing whether people are more inclined to buy fresh fruit or candy, depending on the day of the week",
            "color": "yellow",
            "note": "Example analytics query",
            "chapter": null
        },
        {
            "id": 813,
            "is_deleted": false,
            "representative_text": "Simplicity ",
            "selected_text": "Simplicity",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 814,
            "is_deleted": false,
            "representative_text": "If your application has mostly one-to-many relationships (tree-structured data) or no relationships between records, the document model is appropriate. ",
            "selected_text": "If your application has mostly one-to-many relationships (tree-structured data) or no relationships between records, the document model is appropriate.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 815,
            "is_deleted": false,
            "representative_text": "There is also overhead from having to write an entire page at a time, even if only a few bytes in that page changed. ",
            "selected_text": "There is also overhead from having to write an entire page at a time, even if only a few bytes in that page changed",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 817,
            "is_deleted": false,
            "representative_text": "Frustration with the restrictiveness of relational schemas, and a desire for a more dynamic and expressive data model [5] ",
            "selected_text": "more dynamic and expressive data model ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 818,
            "is_deleted": false,
            "representative_text": "They are usually reluctant to let business analysts run ad hoc analytic queries on an OLTP database, since those queries are often expensive, scanning large parts of the dataset, which can harm the performance of concurrently executing transactions. ",
            "selected_text": "They are usually reluctant to let business analysts run ad hoc analytic queries on an OLTP database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 819,
            "is_deleted": false,
            "representative_text": "Even in \"noncritical\" applications we have a responsibility to our users. ",
            "selected_text": "Even in \"noncritical\" applications we have a responsibility to our users",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 820,
            "is_deleted": false,
            "representative_text": "A compromise between a clustered index (storing all row data within the index) and a nonclustered index (storing only references to the data within the index) is known as a covering index or index with included columns, which stores some of a table's columns within the index [33]. ",
            "selected_text": "A compromise between a clustered index (storing all row data within the index) and a nonclustered index (storing only references to the data within the index",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 821,
            "is_deleted": false,
            "representative_text": "Historically, data started out being represented as one big tree (the hierarchical model), but that wasn't good for representing many-to-many relationships, so the relational model was invented to solve that problem. More recently, developers found that some applications don't fit well in the relational model either. New nonrelational \"NoSQL\" datastores have diverged in two main directions: Document databases target use cases where data comes in self-contained documents and relationships between one document and another are rare. Graph databases go in the opposite direction, targeting use cases where anything is potentially related to everything. ",
            "selected_text": "Historically, data started out being represented as one big tree (the hierarchical model), but that wasn't good for representing many-to-many relationships, so the relational model was invented to solve that problem. More recently, developers found that some applications don't fit well in the relational model either. New nonrelational \"NoSQL\" datastores have diverged in two main directions: Document databases target use cases where data comes in self-contained documents and relationships between one document and another are rare. Graph databases go in the opposite direction, targeting use cases where anything is potentially related to everything.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 822,
            "is_deleted": false,
            "representative_text": "Imperative code is very hard to parallelize across multiple cores and multiple machines, because it specifies instructions that must be performed in a particular order. Declarative languages have a better chance of getting faster in parallel execution because they specify only the pattern of the results, not the algorithm that is used to determine the results. The database is free to use a parallel implementation of the query language, if appropriate [32]. ",
            "selected_text": "Imperative code is very hard to parallelize across multiple cores and multiple machines, because it specifies instructions that must be performed in a particular order. Declarative languages have a better chance of getting faster in parallel execution because they specify only the pattern of the results, not the algorithm that is used to determine the results. The database is free to use a parallel implementation of the query language, if appropriate",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 824,
            "is_deleted": false,
            "representative_text": "Range queries are not efficient. ",
            "selected_text": "Range queries are not efficient",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 825,
            "is_deleted": false,
            "representative_text": "Joins can be emulated in application code by making multiple requests to the database, but that also moves complexity into the application and is usually slower than a join performed by specialized code inside the database. ",
            "selected_text": "Joins can be emulated in application code by making multiple requests to the database, but that also moves complexity into the application and is usually slower than a join performed by specialized code inside the database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 826,
            "is_deleted": false,
            "representative_text": "The things that can go wrong are called faults, and systems that anticipate faults and can cope with them are called fault-tolerant or resilient. ",
            "selected_text": "The things that can go wrong are called faults, and systems that anticipate faults and can cope with them are called fault-tolerant or resilient",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 827,
            "is_deleted": false,
            "representative_text": "Making a system simpler does not necessarily mean reducing its functionality; it can also mean removing accidental complexity. Moseley and Marks [32] define complexity as accidental if it is not inherent in the problem that the software solves (as seen by the users) but arises only from the implementation. ",
            "selected_text": "Making a system simpler does not necessarily mean reducing its functionality; it can also mean removing accidental complexity. Moseley and Marks [32] define complexity as accidental if it is not inherent in the problem that the software solves (as seen by the users) but arises only from the implementation",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 830,
            "is_deleted": false,
            "representative_text": "A downside of log-structured storage is that the compaction process can sometimes interfere with the performance of ongoing reads and writes. ",
            "selected_text": "downside of log-structured storage is that the compaction process can sometimes interfere with the performance of ongoing reads and writes.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 831,
            "is_deleted": false,
            "representative_text": "data is organized into relations (called tables in SQL), where each relation is an unordered collection of tuples (rows in SQL). ",
            "selected_text": "data is organized into relations (called tables in SQL), where each relation is an unordered collection of tuples (rows in SQL).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 832,
            "is_deleted": false,
            "representative_text": "In order to figure out how bad your outliers are, you can look at higher percentiles: the 95th, 99th, and 99.9th percentiles are common (abbreviated p95, p99, and p999). They are the response time thresholds at which 95%, 99%, or 99.9% of requests are faster than that particular threshold. For example, if the 95th percentile response time is 1.5 seconds, that means 95 out of 100 requests take less than 1.5 seconds, and 5 out of 100 requests take 1.5 seconds or more. This is illustrated in Figure 1-4. ",
            "selected_text": "In order to figure out how bad your outliers are, you can look at higher percentiles: the 95th, 99th, and 99.9th percentiles are common (abbreviated p95, p99, and p999). They are the response time thresholds at which 95%, 99%, or 99.9% of requests are faster than that particular threshold. For example, if the 95th percentile response time is 1.5 seconds, that means 95 out of 100 requests take less than 1.5 seconds, and 5 out of 100 requests take 1.5 seconds or more. This is illustrated in Figure 1-4. ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 833,
            "is_deleted": false,
            "representative_text": "LSM-trees are typically faster for writes, whereas B-trees are thought to be faster for reads [23]. ",
            "selected_text": "LSM-trees are typically faster for writes, whereas B-trees are thought to be faster for reads ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 834,
            "is_deleted": false,
            "representative_text": "This works better because the average rate of published tweets is almost two orders of magnitude lower than the rate of home timeline reads, and so in this case it's preferable to do more work at write time and less at read time. ",
            "selected_text": "This works better because the average rate of published tweets is almost two orders of magnitude lower than the rate of home timeline reads, and so in this case it's preferable to do more work at write time and less at read time.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 835,
            "is_deleted": false,
            "representative_text": "The data model of a data warehouse is most commonly relational, because SQL is generally a good fit for analytic queries. ",
            "selected_text": "The data model of a data warehouse is most commonly relational, because SQL is generally a good fit for analytic queries",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 837,
            "is_deleted": false,
            "representative_text": "The database typically needs to load the entire document, even if you access only a small portion of it, which can be wasteful on large documents. ",
            "selected_text": "The database typically needs to load the entire document, even if you access only a small portion of it, which can be wasteful on large documents",
            "color": "yellow",
            "note": "Demerits of doc model",
            "chapter": null
        },
        {
            "id": 838,
            "is_deleted": false,
            "representative_text": "duplicating data when multiple secondary indexes are present: each index just references a location in the heap file, and the actual data is kept in one place. ",
            "selected_text": "each index just references a location in the heap file, and the actual data is kept in one place.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 839,
            "is_deleted": false,
            "representative_text": "cost (e.g., when developing a prototype product for an unproven market) or operational cost (e.g., for a service with a very narrow profit margin)--but we should be very conscious of when we are cutting corners. ",
            "selected_text": "when developing a prototype product for an unproven market",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 840,
            "is_deleted": false,
            "representative_text": "The situation is more complicated if the new value is larger, as it probably needs to be moved to a new location in the heap where there is enough space. In that case, either all indexes need to be updated to point at the new heap location of the record, or a forwarding pointer is left behind in the old heap location [5]. ",
            "selected_text": "The situation is more complicated if the new value is larger, as it probably needs to be moved to a new location in the heap where there is enough space. In that case, either all indexes need to be updated to point at the new heap location of the record, or a forwarding pointer is left behind in the old heap location",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 841,
            "is_deleted": false,
            "representative_text": "This makes the median a good metric if you want to know how long users typically have to wait: half of user requests are served in less than the median response time, and the other half take longer than the median. ",
            "selected_text": "This makes the median a good metric if you want to know how long users typically have to wait: half of user requests are served in less than the median response time, and the other half take longer than the median",
            "color": "yellow",
            "note": "P50",
            "chapter": null
        },
        {
            "id": 842,
            "is_deleted": false,
            "representative_text": "The final twist of the Twitter anecdote: now that approach 2 is robustly implemented, Twitter is moving to a hybrid of both approaches. Most users' tweets continue to be fanned out to home timelines at the time when they are posted, but a small number of users with a very large number of followers (i.e., celebrities) are excepted from this fan-out. ",
            "selected_text": "The final twist of the Twitter anecdote: now that approach 2 is robustly implemented, Twitter is moving to a hybrid of both approaches. Most users' tweets continue to be fanned out to home timelines at the time when they are posted, but a small number of users with a very large number of followers (i.e., celebrities) are excepted from this fan-out",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 843,
            "is_deleted": false,
            "representative_text": "such as LSM-trees, which only append to files (and eventually delete obsolete files) but never modify files in place. ",
            "selected_text": "LSM-trees, which only append to files (and eventually delete obsolete files)",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 844,
            "is_deleted": false,
            "representative_text": "But in cases where all records are expected to have the same structure, schemas are a useful mechanism for documenting and enforcing that structure. ",
            "selected_text": "But in cases where all records are expected to have the same structure, schemas are a useful mechanism for documenting and enforcing that structure",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 845,
            "is_deleted": false,
            "representative_text": "the data usually assumes some kind of structure--i.e., there is an implicit schema, but it is not enforced by the database [20]. ",
            "selected_text": "there is an implicit schema, but it is not enforced by the database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 846,
            "is_deleted": false,
            "representative_text": "The main arguments in favor of the document data model are schema flexibility, better performance due to locality, and that for some applications it is closer to the data structures used by the application. ",
            "selected_text": "The main arguments in favor of the document data model are schema flexibility, better performance due to locality, and that for some applications it is closer to the data structures used by the application",
            "color": "yellow",
            "note": "But no querying by filtering the nested structure ",
            "chapter": null
        },
        {
            "id": 847,
            "is_deleted": false,
            "representative_text": "Compaction means throwing away duplicate keys in the log, and keeping only the most recent update for each key. ",
            "selected_text": "Compaction means throwing away duplicate keys in the log, and keeping only the most recent update for each key. ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 848,
            "is_deleted": false,
            "representative_text": "Usually it is better to use percentiles. If you take your list of response times and sort it from fastest to slowest, then the median is the halfway point: for example, if your median response time is 200 ms, that means half your requests return in less than 200 ms, and half your requests take longer than that. ",
            "selected_text": "Usually it is better to use percentiles. If you take your list of response times and sort it from fastest to slowest, then the median is the halfway point",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 850,
            "is_deleted": false,
            "representative_text": "sparse: one key for every few kilobytes of segment file is sufficient, because a few kilobytes can be scanned very quickly.i ",
            "selected_text": "one key for every few kilobytes of segment file is sufficient",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 851,
            "is_deleted": false,
            "representative_text": "Any kind of index usually slows down writes, because the index also needs to be updated every time data is written. ",
            "selected_text": "Any kind of index usually slows down writes, because the index also needs to be updated every time data is written.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 852,
            "is_deleted": false,
            "representative_text": "In an early-stage startup or an unproven product it's usually more important to be able to iterate quickly on product features than it is to scale to some hypothetical future load. ",
            "selected_text": "In an early-stage startup or an unproven product it's usually more important to be able to iterate quickly on product features than it is to scale to some hypothetical future load.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 853,
            "is_deleted": false,
            "representative_text": "A software project mired in complexity is sometimes described as a big ball of mud [30]. ",
            "selected_text": "A software project mired in complexity is sometimes described as a big ball of mud [30].",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 854,
            "is_deleted": false,
            "representative_text": "bandwidth can be used for the initial write, but the bigger the database gets, the more disk bandwidth is required for compaction. ",
            "selected_text": "but the bigger the database gets, the more disk bandwidth is required for compaction.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 855,
            "is_deleted": false,
            "representative_text": "MapReduce is a programming model for processing large amounts of data in bulk across many machines, popularized by Google [33]. ",
            "selected_text": "MapReduce is a programming model for processing large amounts of data in bulk across many machines",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 856,
            "is_deleted": false,
            "representative_text": "When the relational model was introduced, it included a new way of querying data: SQL is a declarative query language, whereas IMS and CODASYL queried the database using imperative code. ",
            "selected_text": "SQL is a declarative query language",
            "color": "yellow",
            "note": "U tell it what u want.. not how to",
            "chapter": null
        },
        {
            "id": 857,
            "is_deleted": false,
            "representative_text": "It is based on the map (also known as collect) and reduce (also known as fold or inject) functions that exist in many functional programming languages. ",
            "selected_text": "map (also known as collect) and reduce (also known as fold or inject",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 858,
            "is_deleted": false,
            "representative_text": "Operability ",
            "selected_text": "Operability",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 860,
            "is_deleted": false,
            "representative_text": "Some in-memory key-value stores, such as Memcached, are intended for caching use only, where it's acceptable for data to be lost if a machine is restarted. ",
            "selected_text": "Some in-memory key-value stores, such as Memcached, are intended for caching use only, where it's acceptable for data to be lost if a machine is restarted",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 861,
            "is_deleted": false,
            "representative_text": "One common reason for degradation is increased load: perhaps the system has grown from 10,000 concurrent users to 100,000 concurrent users, or from 1 million to 10 million. ",
            "selected_text": "One common reason for degradation is increased load",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 862,
            "is_deleted": false,
            "representative_text": "This is an important trade-off in storage systems: well-chosen indexes speed up read queries, but every index slows down writes. For this reason, databases don't usually index everything by default, but require you--the application developer or database administrator--to choose indexes manually, using your knowledge of the application's typical query patterns. ",
            "selected_text": "This is an important trade-off in storage systems: well-chosen indexes speed up read queries, but every index slows down writes. For this reason, databases don't usually index everything by default, but require you--the application developer or database administrator--to choose indexes manually, using your knowledge of the application's typical query patterns",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 863,
            "is_deleted": false,
            "representative_text": "Specialized query operations that are not well supported by the relational model ",
            "selected_text": "Specialized query operations that are not well supported by the relational model",
            "color": "yellow",
            "note": "Joins ",
            "chapter": null
        },
        {
            "id": 864,
            "is_deleted": false,
            "representative_text": "Moreover, LSM-trees are typically able to sustain higher write throughput than B-trees, partly because they sometimes have lower write amplification (although this depends on the storage engine configuration and workload), and partly because they sequentially write compact SSTable files rather than having to overwrite several pages in the tree [26]. ",
            "selected_text": "B-trees, partly because they sometimes have lower write amplification",
            "color": "yellow",
            "note": "Consequent writes from writes growing over time",
            "chapter": null
        },
        {
            "id": 866,
            "is_deleted": false,
            "representative_text": "The map and reduce functions are somewhat restricted in what they are allowed to do. They must be pure functions, which means they only use the data that is passed to them as input, they cannot perform additional database queries, and they must not have any side effects. ",
            "selected_text": "The map and reduce functions are somewhat restricted in what they are allowed to do. They must be pure functions, which means they only use the data that is passed to them as input, they cannot perform additional database queries",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 867,
            "is_deleted": false,
            "representative_text": "When generating load artificially in order to test the scalability of a system, the load-generating client needs to keep sending requests independently of the response time. If the client waits for the previous request to complete before sending the next one, that behavior has the effect of artificially keeping the queues shorter in the test than they would be in reality, which skews the measurements [23]. ",
            "selected_text": "When generating load artificially in order to test the scalability of a system, the load-generating client needs to keep sending requests independently of the response time. If the client waits for the previous request to complete before sending the next one, that behavior has the effect of artificially keeping the queues shorter in the test than they would be in reality, which skews the measurements",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 868,
            "is_deleted": false,
            "representative_text": "If the data in your application has a document-like structure (i.e., a tree of one-to-many relationships, where typically the entire tree is loaded at once), then it's probably a good idea to use a document model. ",
            "selected_text": "If the data in your application has a document-like structure (i.e., a tree of one-to-many relationships, where typically the entire tree is loaded at once), then it's probably a good idea to use a document model",
            "color": "yellow",
            "note": "Without having to demoralize the data later in rdms, u can use document db ",
            "chapter": null
        },
        {
            "id": 869,
            "is_deleted": false,
            "representative_text": "Moreover, LSM-trees are typically able to sustain higher write throughput than B-trees, partly because they sometimes have lower write amplification (although this depends on the storage engine configuration and workload), and partly because they sequentially write compact SSTable files rather than having to overwrite several pages in the tree [26]. ",
            "selected_text": "Moreover, LSM-trees are typically able to sustain higher write throughput than",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 870,
            "is_deleted": false,
            "representative_text": "In relational databases, you can create several secondary indexes on the same table using the CREATE INDEX command, and they are often crucial for performing joins efficiently. ",
            "selected_text": "you can create several secondary indexes on the same table using the CREATE INDEX command, and they are often crucial for performing joins efficiently.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 871,
            "is_deleted": false,
            "representative_text": "to stop using their OLTP systems for analytics purposes, and to run the analytics on a separate database instead. This separate database was called a data warehouse. ",
            "selected_text": "OLTP systems for analytics purposes, and to run the analytics on a separate database instead. This separate database was called a data warehouse.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 872,
            "is_deleted": false,
            "representative_text": "Many data warehouses are used in a fairly formulaic style, known as a star schema (also known as dimensional modeling [55]). ",
            "selected_text": "Many data warehouses are used in a fairly formulaic style, known as a star schema",
            "color": "yellow",
            "note": "Fact table in middle with dimension tables as rays of a star",
            "chapter": null
        },
        {
            "id": 873,
            "is_deleted": false,
            "representative_text": "One of the best tools we have for removing accidental complexity is abstraction. A good abstraction can hide a great deal of implementation detail behind a clean, simple-to-understand fa\u00e7ade. ",
            "selected_text": "One of the best tools we have for removing accidental complexity is abstraction. A good abstraction can hide a great deal of implementation detail behind a clean, simple-to-understand fa\u00e7ade",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 874,
            "is_deleted": false,
            "representative_text": "A B-tree index must write every piece of data at least twice: once to the write-ahead log, and once to the tree page itself (and perhaps again as pages are split). ",
            "selected_text": "A B-tree index must write every piece of data at least twice: once to the write-ahead log, and once to the tree page itself",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 875,
            "is_deleted": false,
            "representative_text": "It is impossible to reduce the probability of a fault to zero; therefore it is usually best to design fault-tolerance mechanisms that prevent faults from causing failures. ",
            "selected_text": "It is impossible to reduce the probability of a fault to zero; therefore it is usually best to design fault-tolerance mechanisms that prevent faults from causing failures",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 876,
            "is_deleted": false,
            "representative_text": "One thing that document and graph databases have in common is that they typically don't enforce a schema for the data they store, which can make it easier to adapt applications to changing requirements. ",
            "selected_text": "One thing that document and graph databases have in common is that they typically don't enforce a schema for the data they store, which can make it easier to adapt applications to changing requirements",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 877,
            "is_deleted": false,
            "representative_text": "It turns out that the indexing algorithms discussed in the first half of this chapter work well for OLTP, but are not very good at answering analytic queries. ",
            "selected_text": "It turns out that the indexing algorithms discussed in the first half of this chapter work well for OLTP, but are not very good at answering analytic queries",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 878,
            "is_deleted": false,
            "representative_text": "This is easy, using CSS: ",
            "selected_text": "This is easy, using CSS",
            "color": "yellow",
            "note": "CSS is declarative",
            "chapter": null
        },
        {
            "id": 879,
            "is_deleted": false,
            "representative_text": "It is up to the database system's query optimizer to decide which indexes and which join methods to use, and in which order to execute various parts of the query. ",
            "selected_text": "is up to the database system's query optimizer to decide which indexes and which join methods to use, and in which order to execute various parts of the query.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 880,
            "is_deleted": false,
            "representative_text": "If the database itself does not support joins, you have to emulate a join in application code by making multiple queries to the database. ",
            "selected_text": "If the database itself does not support joins, you have to emulate a join in application code by making multiple queries to the database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 881,
            "is_deleted": false,
            "representative_text": "There are many different types of objects, and it is not practical to put each type of object in its own table. The structure of the data is determined by external systems over which you have no control and which may change at any time. ",
            "selected_text": "There are many different types of objects, and it is not practical to put each type of object in its own table. The structure of the data is determined by external systems over which you have no control and which may change at any time.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 882,
            "is_deleted": false,
            "representative_text": "Similarly to what db_set does, many databases internally use a log, which is an append-only data file. ",
            "selected_text": "Similarly to what db_set does, many databases internally use a log, which is an append-only data file",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 884,
            "is_deleted": false,
            "representative_text": "The column-oriented storage layout relies on each column file containing the rows in the same order. Thus, if you need to reassemble an entire row, you can take the 23rd entry from each of the individual column files and put them together to form the 23rd row of the table. ",
            "selected_text": "The column-oriented storage layout relies on each column file containing the rows in the same order. Thus, if you need to reassemble an entire row, you can take the 23rd entry from each of the individual column files and put them together to form the 23rd row of the table.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 885,
            "is_deleted": false,
            "representative_text": "The idea behind column-oriented storage is simple: don't store all the values from one row together, but store all the values from each column together instead. If each column is stored in a separate file, a query only needs to read and parse those columns that are used in that query, which can save a lot of work. ",
            "selected_text": "The idea behind column-oriented storage is simple: don't store all the values from one row together, but store all the values from each column together instead. ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 886,
            "is_deleted": false,
            "representative_text": "One way of creating such a cache is a materialized view. In a relational data model, it is often defined like a standard (virtual) view: a table-like object whose contents are the results of some query. ",
            "selected_text": "One way of creating such a cache is a materialized view. In a relational data model, it is often defined like a standard (virtual) view: a table-like object whose contents are the results of some query",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 887,
            "is_deleted": false,
            "representative_text": "Fortunately, we have already seen a good solution earlier in this chapter: LSM-trees. All writes first go to an in-memory store, where they are added to a sorted structure and prepared for writing to disk. It doesn't matter whether the in-memory store is row-oriented or column-oriented. When enough writes have accumulated, they are merged with the column files on disk and written to new files in bulk. ",
            "selected_text": "LSM-trees. All writes first go to an in-memory store, where they are added to a sorted structure and prepared for writing to disk. It doesn't matter whether the in-memory store is row-oriented or column-oriented. When enough writes have accumulated, they are merged with the column files on disk and written to new files in bulk",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 888,
            "is_deleted": false,
            "representative_text": "However, they have the downside of making writes more difficult. An update-in-place approach, like B-trees use, is not possible with compressed columns. If you wanted to insert a row in the middle of a sorted table, you would most likely have to rewrite all the column files. As rows are identified by their position within a column, the insertion has to update all columns consistently. ",
            "selected_text": "However, they have the downside of making writes more difficult. An update-in-place approach, like B-trees use, is not possible with compressed columns. If you wanted to insert a row in the middle of a sorted table, you would most likely have to rewrite all the column files. As rows are identified by their position within a column, the insertion has to update all columns consistently.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 889,
            "is_deleted": false,
            "representative_text": "A common special case of a materialized view is known as a data cube or OLAP cube [64]. ",
            "selected_text": "A common special case of a materialized view is known as a data cube or OLAP cube",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 890,
            "is_deleted": false,
            "representative_text": "The application requests records using some kind of key, and the storage engine uses an index to find the data for the requested key. Disk seek time is often the bottleneck here. ",
            "selected_text": "The application requests records using some kind of key, and the storage engine uses an index to find the data for the requested key. Disk seek time is often the bottleneck here.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 891,
            "is_deleted": false,
            "representative_text": "When the underlying data changes, a materialized view needs to be updated, because it is a denormalized copy of the data. The database can do that automatically, but such updates make writes more expensive, which is why materialized views are not often used in OLTP databases. In read-heavy data warehouses they can make more sense (whether or not they actually improve read performance depends on the individual case). ",
            "selected_text": "When the underlying data changes, a materialized view needs to be updated, because it is a denormalized copy of the data. The database can do that automatically, but such updates make writes more expensive, which is why materialized views are not often used in OLTP databases. In read-heavy data warehouses they can make more sense",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 892,
            "is_deleted": false,
            "representative_text": "OLTP systems are typically user-facing, which means that they may see a huge volume of requests. ",
            "selected_text": "OLTP systems are typically user-facing, which means that they may see a huge volume of requests",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 893,
            "is_deleted": false,
            "representative_text": "systems, but each query is typically very demanding, requiring many millions of records to be scanned in a short time. ",
            "selected_text": "but each query is typically very demanding, requiring many millions of records to be scanned in a short time",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 894,
            "is_deleted": false,
            "representative_text": "A key design goal of a service-oriented/microservices architecture is to make the application easier to change and maintain by making services independently deployable and evolvable. ",
            "selected_text": "A key design goal of a service-oriented/microservices architecture is to make the application easier to change and maintain by making services independently deployable and evolvable",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 895,
            "is_deleted": false,
            "representative_text": "WSDL enables code generation so that a client can access a remote service using local classes and method calls (which are encoded to XML messages and decoded again by the framework). ",
            "selected_text": "WSDL enables code generation so that a client can access a remote service using local classes and method calls",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 896,
            "is_deleted": false,
            "representative_text": "Programming language-specific encodings are restricted to a single programming language and often fail to provide forward and backward compatibility. ",
            "selected_text": "Programming language-specific encodings are restricted to a single programming language and often fail to provide forward and backward compatibility.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 897,
            "is_deleted": false,
            "representative_text": "Consistent Prefix Reads ",
            "selected_text": "Consistent Prefix Reads",
            "color": "yellow",
            "note": "Different partitions operate at different latency. Some part of data maybe up to date and some part may be out of date.",
            "chapter": null
        },
        {
            "id": 898,
            "is_deleted": false,
            "representative_text": "The client can remember the timestamp of its most recent write--then the system can ensure that the replica serving any reads for that user reflects updates at least until that timestamp. ",
            "selected_text": "The client can remember the timestamp of its most recent write--then the system can ensure that the replica serving any reads for that user reflects updates at least until that timestamp",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 899,
            "is_deleted": false,
            "representative_text": "Many programming languages come with built-in support for encoding in-memory objects into byte sequences. For example, Java has java.io.Serializable [1], Ruby has Marshal [2], Python has pickle [3], and so on. ",
            "selected_text": "Many programming languages come with built-in support for encoding in-memory objects into byte sequences. For example, Java has java.io.Serializable [1], Ruby has Marshal [2], Python has pickle [3], and so on",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 900,
            "is_deleted": false,
            "representative_text": "Consequently, Avro doesn't have optional and required markers in the same way as Protocol Buffers and Thrift do (it has union types and default values instead). ",
            "selected_text": "Consequently, Avro doesn't have optional and required markers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 901,
            "is_deleted": false,
            "representative_text": "The biggest problem with multi-leader replication is that write conflicts can occur, which means that conflict resolution is required. ",
            "selected_text": "The biggest problem with multi-leader replication is that write conflicts can occur, which means that conflict resolution is required",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 902,
            "is_deleted": false,
            "representative_text": "Custom RPC protocols with a binary encoding format can achieve better performance than something generic like JSON over REST. ",
            "selected_text": "Custom RPC protocols with a binary encoding format can achieve better performance than something generic like JSON over REST",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 903,
            "is_deleted": false,
            "representative_text": "easy encoding of data, they often neglect the inconvenient problems of forward and backward compatibility. ",
            "selected_text": "they often neglect the inconvenient problems of forward and backward compatibility.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 904,
            "is_deleted": false,
            "representative_text": "In the case of a B-tree (see \"B-Trees\"), which overwrites individual disk blocks, every modification is first written to a write-ahead log so that the index can be restored to a consistent state after a crash. ",
            "selected_text": "In the case of a B-tree (see \"B-Trees\"), which overwrites individual disk blocks, every modification is first written to a write-ahead log so that the index can be restored to a consistent state after a crash.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 905,
            "is_deleted": false,
            "representative_text": "JSON distinguishes strings and numbers, but it doesn't distinguish integers and floating-point numbers, and it doesn't specify a precision. ",
            "selected_text": "JSON distinguishes strings and numbers, but it doesn't distinguish integers and floating-point numbers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 906,
            "is_deleted": false,
            "representative_text": "When you call a local function, you can efficiently pass it references (pointers) to objects in local memory. When you make a network request, all those parameters need to be encoded into a sequence of bytes that can be sent over the network. ",
            "selected_text": "When you call a local function, you can efficiently pass it references (pointers) to objects in local memory. When you make a network request, all those parameters need to be encoded into a sequence of bytes that can be sent over the network",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 907,
            "is_deleted": false,
            "representative_text": "However, they have the downside that data needs to be decoded before it is human-readable. ",
            "selected_text": "However, they have the downside that data needs to be decoded before it is human-readable.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 908,
            "is_deleted": false,
            "representative_text": "Each follower takes the log from the leader and updates its local copy of the database accordingly, by applying all writes in the same order as they were processed on the leader. ",
            "selected_text": "Each follower takes the log from the leader and updates its local copy of the database accordingly,",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 909,
            "is_deleted": false,
            "representative_text": "However, for faster collaboration, you may want to make the unit of change very small (e.g., a single keystroke) and avoid locking. This approach allows multiple users to edit simultaneously, but it also brings all the challenges of multi-leader replication, including requiring conflict resolution [32]. ",
            "selected_text": "However, for faster collaboration, you may want to make the unit of change very small (e.g., a single keystroke) and avoid locking. This approach allows multiple users to edit simultaneously, but it also brings all the challenges of multi-leader replication, including requiring conflict resolution",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 910,
            "is_deleted": false,
            "representative_text": "The problem with a shared-memory approach is that the cost grows faster than linearly: a machine with twice as many CPUs, twice as much RAM, and twice as much disk capacity as another typically costs significantly more than twice as much. ",
            "selected_text": "The problem with a shared-memory approach is that the cost grows faster than linearly",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 911,
            "is_deleted": false,
            "representative_text": "Now, if the database schema changes (for example, a table has one column added and one column removed), you can just generate a new Avro schema from the updated database schema and export data in the new Avro schema. The data export process does not need to pay any attention to the schema change--it can simply do the schema conversion every time it runs. ",
            "selected_text": "Now, if the database schema changes (for example, a table has one column added and one column removed), you can just generate a new Avro schema from the updated database schema and export data in the new Avro schema. The data export process does not need to pay any attention to the schema change",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 912,
            "is_deleted": false,
            "representative_text": "The API of a SOAP web service is described using an XML-based language called the Web Services Description Language, or WSDL. ",
            "selected_text": "The API of a SOAP web service is described using an XML-based language called the Web Services Description Language, or WSDL",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 913,
            "is_deleted": false,
            "representative_text": "The main focus of RPC frameworks is on requests between services owned by the same organization, typically within the same datacenter. ",
            "selected_text": "The main focus of RPC frameworks is on requests between services owned by the same organization, typically within the same datacenter.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 914,
            "is_deleted": false,
            "representative_text": "For example, in an application where a user can edit their own data, you can ensure that requests from a particular user are always routed to the same datacenter and use the leader in that datacenter for reading and writing. ",
            "selected_text": "For example, in an application where a user can edit their own data, you can ensure that requests from a particular user are always routed to the same datacenter and use the leader in that datacenter for reading and writing",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 915,
            "is_deleted": false,
            "representative_text": "By contrast, SOAP is an XML-based protocol for making network API requests.vii Although it is most commonly used over HTTP, it aims to be independent from HTTP and avoids using most HTTP features. ",
            "selected_text": "SOAP is an XML-based protocol for making network API requests",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 916,
            "is_deleted": false,
            "representative_text": "The disadvantage is that if the synchronous follower doesn't respond (because it has crashed, or there is a network fault, or for any other reason), the write cannot be processed. The leader must block all writes and wait until the synchronous replica is available again. ",
            "selected_text": "The disadvantage is that if the synchronous follower doesn't respond (because it has crashed, or there is a network fault, or for any other reason), the write cannot be processed. The leader must block all writes and wait until the synchronous replica is available again.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 917,
            "is_deleted": false,
            "representative_text": "A network request has another possible outcome: it may return without a result, due to a timeout. ",
            "selected_text": "A network request has another possible outcome: it may return without a result, due to a timeout",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 918,
            "is_deleted": false,
            "representative_text": "Leader-based replication has one major downside: there is only one leader, and all writes must go through it.iv If you can't connect to the leader for any reason, for example due to a network interruption between you and the leader, you can't write to the database. ",
            "selected_text": "Leader-based replication has one major downside: there is only one leader, and all writes must go through it",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 919,
            "is_deleted": false,
            "representative_text": "The simplest strategy for dealing with conflicts is to avoid them: if the application can ensure that all writes for a particular record go through the same leader, then conflicts cannot occur. ",
            "selected_text": "if the application can ensure that all writes for a particular record go through the same leader, then conflicts cannot occur.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 920,
            "is_deleted": false,
            "representative_text": "By contrast, if you were using Thrift or Protocol Buffers for this purpose, the field tags would likely have to be assigned by hand: every time the database schema changes, an administrator would have to manually update the mapping from database column names to field tags. (It might be possible to automate this, but the schema generator would have to be very careful to not assign previously used field tags.) ",
            "selected_text": "By contrast, if you were using Thrift or Protocol Buffers for this purpose, the field tags would likely have to be assigned by hand: every time the database schema changes, an administrator would have to manually update the mapping from database column names to field tags. ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 921,
            "is_deleted": false,
            "representative_text": "Databases, where the process writing to the database encodes the data and the process reading from the database decodes it ",
            "selected_text": "Databases, where the process writing to the database encodes the data and the process reading from the database decodes it",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 922,
            "is_deleted": false,
            "representative_text": "The web works this way: clients (web browsers) make requests to web servers, making GET requests to download HTML, CSS, JavaScript, images, etc., and making POST requests to submit data to the server. The API consists of a standardized set of protocols and data formats (HTTP, URLs, SSL/TLS, HTML, etc.). Because web browsers, web servers, and website authors mostly agree on these standards, you can use any web browser to access any website (at least in theory!). ",
            "selected_text": "The web works this way: clients (web browsers) make requests to web servers, making GET requests to download HTML, CSS, JavaScript, images, etc., and making POST requests to submit data to the server. The API consists of a standardized set of protocols and data formats (HTTP, URLs, SSL/TLS, HTML, etc.). Because web browsers, web servers, and website authors mostly agree on these standards, you can use any web browser to access any website",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 923,
            "is_deleted": false,
            "representative_text": "JSON and XML have good support for Unicode character strings (i.e., human-readable text), but they don't support binary strings (sequences of bytes without a character encoding). ",
            "selected_text": "Unicode character strings (i.e., human-readable text",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 924,
            "is_deleted": false,
            "representative_text": "Keeping a copy of the same data on several different nodes, potentially in different locations. ",
            "selected_text": "Keeping a copy of the same data on several different nodes, potentially in different locations",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 925,
            "is_deleted": false,
            "representative_text": "Every write to the database needs to be processed by every replica; otherwise, the replicas would no longer contain the same data. The most common solution for this is called leader-based replication (also known as active/passive or master-slave replication) and is illustrated in Figure 5-1. ",
            "selected_text": "Every write to the database needs to be processed by every replica; otherwise, the replicas would no longer contain the same data. The most common solution for this is called leader-based replication (also known as active/passive or master-slave replication) and is illustrated",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 926,
            "is_deleted": false,
            "representative_text": "A logical log format is also easier for external applications to parse. This aspect is useful if you want to send the contents of a database to an external system, such as a data warehouse for offline analysis, or for building custom indexes and caches [18]. ",
            "selected_text": "A logical log format is also easier for external applications to parse. This aspect is useful if you want to send the contents of a database to an external system",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 927,
            "is_deleted": false,
            "representative_text": "The client and the service may be implemented in different programming languages, so the RPC framework must translate datatypes from one language into another. ",
            "selected_text": "The client and the service may be implemented in different programming languages, so the RPC framework must translate datatypes from one language into another",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 928,
            "is_deleted": false,
            "representative_text": "First of all, notice that there are no tag numbers in the schema. If we encode our example record (Example 4-1) using this schema, the Avro binary encoding is just 32 bytes long--the most compact of all the encodings we have seen. ",
            "selected_text": "First of all, notice that there are no tag numbers in the schema. If we encode our example record (Example 4-1) using this schema, the Avro binary encoding is just 32 bytes long--the most compact of all the encodings we have seen",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 929,
            "is_deleted": false,
            "representative_text": "brokers are used as follows: one process sends a message to a named queue or topic, and the broker ensures that the message is delivered to one or more consumers of or subscribers to that queue or topic. There can be many producers and many consumers on the same topic. ",
            "selected_text": "one process sends a message to a named queue or topic, and the broker ensures that the message is delivered to one or more consumers of or subscribers to that queue or topic. There can be many producers and many consumers on the same topic.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 930,
            "is_deleted": false,
            "representative_text": "In dynamically typed programming languages such as JavaScript, Ruby, or Python, there is not much point in generating code, since there is no compile-time type checker to satisfy. Code generation is often frowned upon in these languages, since they otherwise avoid an explicit compilation step. ",
            "selected_text": "In dynamically typed programming languages such as JavaScript, Ruby, or Python, there is not much point in generating code, since there is no compile-time type checker to satisfy. Code generation is often frowned upon in these languages, since they otherwise avoid an explicit compilation step",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 931,
            "is_deleted": false,
            "representative_text": "A network request is unpredictable: the request or response may be lost due to a network problem, or the remote machine may be slow or unavailable, and such problems are entirely outside of your control. ",
            "selected_text": "network request is unpredictable: the request or response may be lost due to a network problem, or the remote machine may be slow or unavailable, and such problems are entirely outside of your control",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 932,
            "is_deleted": false,
            "representative_text": "Asynchronous message passing (using message brokers or actors), where nodes communicate by sending each other messages that are encoded by the sender and decoded by the recipient ",
            "selected_text": "Asynchronous message passing (using message brokers or actors), where nodes communicate by sending each other messages that are encoded by the sender and decoded by the recipient",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 933,
            "is_deleted": false,
            "representative_text": "When you read data, you may see an old value; monotonic reads only means that if one user makes several reads in sequence, they will not see time go backward--i.e., they will not read older data after having previously read newer data. One way of achieving monotonic reads is to make sure that each user always makes their reads from the same replica (different users can read from different replicas). For example, the replica can be chosen based on a hash of the user ID, rather than randomly. ",
            "selected_text": "monotonic reads only means that if one user makes several reads in sequence, they will not see time go backward--i.e., they will not read older data after having previously read newer data. One way of achieving monotonic reads is to make sure that each user always makes their reads from the same replica (different users can read from different replicas). For example, the replica can be chosen based on a hash of the user ID",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 934,
            "is_deleted": false,
            "representative_text": "It can act as a buffer if the recipient is unavailable or overloaded, and thus improve system reliability. ",
            "selected_text": "It can act as a buffer if the recipient is unavailable or overloaded",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 935,
            "is_deleted": false,
            "representative_text": "Monotonic Reads ",
            "selected_text": "Monotonic Reads",
            "color": "yellow",
            "note": "Read query from different followers may give different results.",
            "chapter": null
        },
        {
            "id": 936,
            "is_deleted": false,
            "representative_text": "When you want to write data to a file or send it over the network, you have to encode it as some kind of self-contained sequence of bytes (for example, a JSON document). ",
            "selected_text": "When you want to write data to a file or send it over the network, you have to encode it as some kind of self-contained sequence of bytes",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 937,
            "is_deleted": false,
            "representative_text": "asynchronous: the sender doesn't wait for the message to be delivered, but simply sends it and then forgets about it. ",
            "selected_text": "the sender doesn't wait for the message to be delivered, but simply sends it and then forgets about it",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 938,
            "is_deleted": false,
            "representative_text": "In order to restore data in the same object types, the decoding process needs to be able to instantiate arbitrary classes. ",
            "selected_text": "the decoding process needs to be able to instantiate arbitrary classes",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 939,
            "is_deleted": false,
            "representative_text": "This problem does not occur in a single-leader database. ",
            "selected_text": "This problem does not occur in a single-leader database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 940,
            "is_deleted": false,
            "representative_text": "It can automatically redeliver messages to a process that has crashed, and thus prevent messages from being lost. ",
            "selected_text": "It can automatically redeliver messages to a process that has crashed, and thus prevent messages from being lost.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 941,
            "is_deleted": false,
            "representative_text": "Real-time collaborative editing applications allow several people to edit a document simultaneously. ",
            "selected_text": "Real-time collaborative editing applications allow several people to edit a document simultaneously",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 942,
            "is_deleted": false,
            "representative_text": "The best candidate for leadership is usually the replica with the most up-to-date data changes from the old leader (to minimize any data loss). ",
            "selected_text": "The best candidate for leadership is usually the replica with the most up-to-date data changes from the old leader",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 943,
            "is_deleted": false,
            "representative_text": "Problems with Replication Lag ",
            "selected_text": "Replication Lag",
            "color": "yellow",
            "note": "Only concerned with asynchronous replication.",
            "chapter": null
        },
        {
            "id": 944,
            "is_deleted": false,
            "representative_text": "Conceptually, the process looks like this: ",
            "selected_text": "Conceptually, the process looks like this:",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 945,
            "is_deleted": false,
            "representative_text": "When reading something that the user may have modified, read it from the leader; otherwise, read it from a follower. ",
            "selected_text": "When reading something that the user may have modified, read it from the leader; otherwise, read it from a follower",
            "color": "yellow",
            "note": "Strong consistency for data that matters to the user, eventual consistency for other data",
            "chapter": null
        },
        {
            "id": 946,
            "is_deleted": false,
            "representative_text": "For that reason, it is impractical for all followers to be synchronous: any one node outage would cause the whole system to grind to a halt. ",
            "selected_text": "For that reason, it is impractical for all followers to be synchronous: any one node outage would cause the whole system to grind to a halt",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 947,
            "is_deleted": false,
            "representative_text": "Another approach is the shared-disk architecture, which uses several machines with independent CPUs and RAM, but stores data on an array of disks that is shared between the machines, which are connected via a fast network.ii This architecture is used for some data warehousing workloads, but contention and the overhead of locking limit the scalability of the shared-disk approach [2]. ",
            "selected_text": "Another approach is the shared-disk architecture, which uses several machines with independent CPUs and RAM, but stores data on an array of disks that is shared between the machines, which are connected via a fast network.ii This architecture is used for some data warehousing workloads, but contention and the overhead of locking limit the scalability of the shared-disk approach",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 948,
            "is_deleted": false,
            "representative_text": "It allows one message to be sent to several recipients. ",
            "selected_text": "It allows one message to be sent to several recipients.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 949,
            "is_deleted": false,
            "representative_text": "JSON is less verbose than XML, but both still use a lot of space compared to binary formats. ",
            "selected_text": "use a lot of space",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 951,
            "is_deleted": false,
            "representative_text": "It logically decouples the sender from the recipient (the sender just publishes messages and doesn't care who consumes them). ",
            "selected_text": "It logically decouples the sender from the recipient ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 952,
            "is_deleted": false,
            "representative_text": "To parse the binary data, you go through the fields in the order that they appear in the schema and use the schema to tell you the datatype of each field. This means that the binary data can only be decoded correctly if the code reading the data is using the exact same schema as the code that wrote the data. Any mismatch in the schema between the reader and the writer would mean incorrectly decoded data. ",
            "selected_text": "To parse the binary data, you go through the fields in the order that they appear in the schema and use the schema to tell you the datatype of each field. This means that the binary data can only be decoded correctly if the code reading the data is using the exact same schema as the code that wrote the data. Any mismatch in the schema between the reader and the writer would mean incorrectly decoded data.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 953,
            "is_deleted": false,
            "representative_text": "The simplest solution is to include a version number at the beginning of every encoded record, and to keep a list of schema versions in your database. ",
            "selected_text": "The simplest solution is to include a version number at the beginning of every encoded record, and to keep a list of schema versions in your database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 954,
            "is_deleted": false,
            "representative_text": "Synchronous Versus Asynchronous Replication ",
            "selected_text": "Synchronous Versus Asynchronous Replication",
            "color": "yellow",
            "note": "Asynchronous = eventual consistency, high availability Synchronous = strong consistency, low availability ",
            "chapter": null
        },
        {
            "id": 955,
            "is_deleted": false,
            "representative_text": "has gone wrong, so most systems simply use a timeout: nodes frequently bounce messages back and forth between each other, and if a node doesn't respond for some period of time--say, 30 seconds--it is assumed to be dead. ",
            "selected_text": "so most systems simply use a timeout: nodes frequently bounce messages back and forth between each other, and if a node doesn't respond for some period of time--say, 30 seconds--it is assumed to be dead",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 956,
            "is_deleted": false,
            "representative_text": "One solution is to make sure that any writes that are causally related to each other are written to the same partition--but in some applications that cannot be done efficiently. ",
            "selected_text": "One solution is to make sure that any writes that are causally related to each other are written to the same partition--but in some applications that cannot be done efficiently.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 957,
            "is_deleted": false,
            "representative_text": "These formats are somewhat vague about datatypes, so you have to be careful with things like numbers and binary strings. ",
            "selected_text": "These formats are somewhat vague about datatypes, so you have to be careful with things like numbers and binary strings.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 958,
            "is_deleted": false,
            "representative_text": "It avoids the sender needing to know the IP address and port number of the recipient (which is particularly useful in a cloud deployment where virtual machines often come and go). ",
            "selected_text": "It avoids the sender needing to know the IP address and port number of the recipient",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 959,
            "is_deleted": false,
            "representative_text": "They are similar to RPC in that a client's request (usually called a message) is delivered to another process with low latency. They are similar to databases in that the message is not sent via a direct network connection, but goes via an intermediary called a message broker (also called a message queue or message-oriented middleware), which stores the message temporarily. ",
            "selected_text": "They are similar to RPC in that a client's request (usually called a message) is delivered to another process with low latency. They are similar to databases in that the message is not sent via a direct network connection, but goes via an intermediary called a message broker",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 960,
            "is_deleted": false,
            "representative_text": "An alternative is to use different log formats for replication and for the storage engine, which allows the replication log to be decoupled from the storage engine internals. This kind of replication log is called a logical log, to distinguish it from the storage engine's (physical) data representation. ",
            "selected_text": "An alternative is to use different log formats for replication and for the storage engine, which allows the replication log to be decoupled from the storage engine internals. This kind of replication log is called a logical log",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 962,
            "is_deleted": false,
            "representative_text": "possible for a user to see things moving backward in time. ",
            "selected_text": "moving backward in time.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 963,
            "is_deleted": false,
            "representative_text": "JSON and XML have good support for Unicode character strings (i.e., human-readable text), but they don't support binary strings (sequences of bytes without a character encoding). Binary strings are a useful feature, so people get around this limitation by encoding the binary data as text using Base64. ",
            "selected_text": "but they don't support binary strings (sequences of bytes without a character encoding). Binary strings are a useful feature, so people get around this limitation by encoding the binary data as text using Base64",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 964,
            "is_deleted": false,
            "representative_text": "If you want synchronous conflict detection, you might as well just use single-leader replication. ",
            "selected_text": "If you want synchronous conflict detection, you might as well just use single-leader replication.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 965,
            "is_deleted": false,
            "representative_text": "For workloads that consist of mostly reads and only a small percentage of writes (a common pattern on the web), there is an attractive option: create many followers, and distribute the read requests across those followers. ",
            "selected_text": "For workloads that consist of mostly reads and only a small percentage of writes (a common pattern on the web), there is an attractive option: create many followers, and distribute the read requests across those followers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 966,
            "is_deleted": false,
            "representative_text": "database: if you run the same query on the leader and a follower at the same time, you may get different results, because not all writes have been reflected in the follower. ",
            "selected_text": "if you run the same query on the leader and a follower at the same time, you may get different results, because not all writes have been reflected in the follower",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 967,
            "is_deleted": false,
            "representative_text": "hot standbys).i Whenever the leader writes new data to its local storage, it also sends the data change to all of its followers as part of a replication log or change stream. ",
            "selected_text": "it also sends the data change to all of its followers as part of a replication log or change stream",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 968,
            "is_deleted": false,
            "representative_text": "With Avro, forward compatibility means that you can have a new version of the schema as writer and an old version of the schema as reader. Conversely, backward compatibility means that you can have a new version of the schema as reader and an old version as writer. ",
            "selected_text": "With Avro, forward compatibility means that you can have a new version of the schema as writer and an old version of the schema as reader. Conversely, backward compatibility means that you can have a new version of the schema as reader and an old version as writer.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 969,
            "is_deleted": false,
            "representative_text": "RPC and REST APIs, where the client encodes a request, the server decodes the request and encodes a response, and the client finally decodes the response ",
            "selected_text": "RPC and REST APIs, where the client encodes a request, the server decodes the request and encodes a response, and the client finally decodes the response",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 970,
            "is_deleted": false,
            "representative_text": "Thrift has a dedicated list datatype, which is parameterized with the datatype of the list elements. This does not allow the same evolution from single-valued to multi-valued as Protocol Buffers does, but it has the advantage of supporting nested lists. ",
            "selected_text": "Thrift has a dedicated list datatype, which is parameterized with the datatype of the list elements. This does not allow the same evolution from single-valued to multi-valued as Protocol Buffers does, but it has the advantage of supporting nested lists.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 971,
            "is_deleted": false,
            "representative_text": "On its local disk, each follower keeps a log of the data changes it has received from the leader. If a follower crashes and is restarted, or if the network between the leader and the follower is temporarily interrupted, the follower can recover quite easily: from its log, it knows the last transaction that was processed before the fault occurred. ",
            "selected_text": "On its local disk, each follower keeps a log of the data changes it has received from the leader. ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 972,
            "is_deleted": false,
            "representative_text": "A network request is much slower than a function call, and its latency is also wildly variable: at good times it may complete in less than a millisecond, but when the network is congested or the remote service is overloaded it may take many seconds to do exactly the same thing. ",
            "selected_text": "A network request is much slower than a function call",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 973,
            "is_deleted": false,
            "representative_text": "Both Thrift and Protocol Buffers require a schema for any data that is encoded. ",
            "selected_text": "Both Thrift and Protocol Buffers require a schema for any data that is encoded",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 974,
            "is_deleted": false,
            "representative_text": "Splitting a big database into smaller subsets called partitions so that different partitions can be assigned to different nodes (also known as sharding). ",
            "selected_text": "Splitting a big database into smaller subsets called partitions so that different partitions can be assigned to different nodes (also known as sharding).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 975,
            "is_deleted": false,
            "representative_text": "REST is not a protocol, but rather a design philosophy that builds upon the principles of HTTP [34, 35]. ",
            "selected_text": "REST is not a protocol, but rather a design philosophy that builds upon the principles of HTTP ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 976,
            "is_deleted": false,
            "representative_text": "If you want to guarantee that there will be no editing conflicts, the application must obtain a lock on the document before a user can edit it. If another user wants to edit the same document, they first have to wait until the first user has committed their changes and released the lock. This collaboration model is equivalent to single-leader replication with transactions on the leader. ",
            "selected_text": "If you want to guarantee that there will be no editing conflicts, the application must obtain a lock on the document before a user can edit it. If another user wants to edit the same document, they first have to wait until the first user has committed their changes and released the lock. This collaboration model is equivalent to single-leader replication with transactions on the leader.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 977,
            "is_deleted": false,
            "representative_text": "When two processes are communicating over a bidirectional network connection, they can negotiate the schema version on connection setup and then use that schema for the lifetime of the connection. ",
            "selected_text": "When two processes are communicating over a bidirectional network connection, they can negotiate the schema version on connection setup and then use that schema for the lifetime of the connection",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 978,
            "is_deleted": false,
            "representative_text": "If the code reading the data encounters a field that appears in the writer's schema but not in the reader's schema, it is ignored. If the code reading the data expects some field, but the writer's schema does not contain a field of that name, it is filled in with a default value declared in the reader's schema. ",
            "selected_text": "If the code reading the data encounters a field that appears in the writer's schema but not in the reader's schema, it is ignored. If the code reading the data expects some field, but the writer's schema does not contain a field of that name, it is filled in with a default value declared in the reader's schema",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 979,
            "is_deleted": false,
            "representative_text": "The key idea with Avro is that the writer's schema and the reader's schema don't have to be the same--they only need to be compatible. When data is decoded (read), the Avro library resolves the differences by looking at the writer's schema and the reader's schema side by side and translating the data from the writer's schema into the reader's schema. ",
            "selected_text": "The key idea with Avro is that the writer's schema and the reader's schema don't have to be the same--they only need to be compatible. When data is decoded (read), the Avro library resolves the differences by looking at the writer's schema and the reader's schema side by side and translating the data from the writer's schema into the reader's schema",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 980,
            "is_deleted": false,
            "representative_text": "One of the replicas is designated the leader (also known as master or primary). When clients want to write to the database, they must send their requests to the leader, which first writes the new data to its local storage. The other replicas are known as followers (read replicas, slaves, secondaries, or hot standbys).i Whenever the leader writes new data to its local storage, it also sends the data change to all of its followers as part of a replication log or change stream. ",
            "selected_text": "One of the replicas is designated the leader (also known as master or primary). When clients want to write to the database, they must send their requests to the leader, which first writes the new data to its local storage. The other replicas are known as followers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 981,
            "is_deleted": false,
            "representative_text": "In this setup, each leader simultaneously acts as a follower to the other leaders. ",
            "selected_text": "In this setup, each leader simultaneously acts as a follower to the other leaders.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 982,
            "is_deleted": false,
            "representative_text": "The encoding is often tied to a particular programming language, and reading the data in another language is very difficult. ",
            "selected_text": "The encoding is often tied to a particular programming language",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 983,
            "is_deleted": false,
            "representative_text": "example, if you decode a database value into model objects in the application, and later reencode those model objects, the unknown field might be lost in that translation process. ",
            "selected_text": "if you decode a database value into model objects in the application",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 984,
            "is_deleted": false,
            "representative_text": "There is a lot of ambiguity around the encoding of numbers. ",
            "selected_text": "There is a lot of ambiguity around the encoding of numbers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 985,
            "is_deleted": false,
            "representative_text": "When a client wants to read from the database, it can query either the leader or any of the followers. However, writes are only accepted on the leader (the followers are read-only from the client's point of view). ",
            "selected_text": "When a client wants to read from the database, it can query either the leader or any of the followers. However, writes are only accepted on the leader",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 986,
            "is_deleted": false,
            "representative_text": "The RPC model tries to make a request to a remote network service look the same as calling a function or method in your programming language, within the same process (this abstraction is called location transparency). ",
            "selected_text": "The RPC model tries to make a request to a remote network service look the same as calling a function or method in your programming language, within the same process (this abstraction is called location transparency",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 987,
            "is_deleted": false,
            "representative_text": "In the example of Figure 5-2, the replication to follower 1 is synchronous: the leader waits until follower 1 has confirmed that it received the write before reporting success to the user, and before making the write visible to other clients. The replication to follower 2 is asynchronous: the leader sends the message, but doesn't wait for a response from the follower. ",
            "selected_text": "In the example of Figure 5-2, the replication to follower 1 is synchronous: the leader waits until follower 1 has confirmed that it received the write before reporting success to the user, and before making the write visible to other clients. The replication to follower 2 is asynchronous:",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 988,
            "is_deleted": false,
            "representative_text": "Binary schema-driven formats like Thrift, Protocol Buffers, and Avro allow compact, efficient encoding with clearly defined forward and backward compatibility semantics. ",
            "selected_text": "efficient encoding with clearly defined forward and backward compatibility semantics",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 989,
            "is_deleted": false,
            "representative_text": "You could also monitor the replication lag on followers and prevent queries on any follower that is more than one minute behind the leader. ",
            "selected_text": "You could also monitor the replication lag on followers and prevent queries on any follower that is more than one minute behind the leader.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 990,
            "is_deleted": false,
            "representative_text": "Any statement that calls a nondeterministic function, such as NOW() to get the current date and time or RAND() to get a random number, is likely to generate a different value on each replica. ",
            "selected_text": "Any statement that calls a nondeterministic function, such as NOW() to get the current date and time or RAND() to get a random number, is likely to generate a different value on each replica.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 991,
            "is_deleted": false,
            "representative_text": "As multi-leader replication is a somewhat retrofitted feature in many databases, there are often subtle configuration pitfalls and surprising interactions with other database features. For example, autoincrementing keys, triggers, and integrity constraints can be problematic. For this reason, multi-leader replication is often considered dangerous territory that should be avoided if possible [28]. ",
            "selected_text": "As multi-leader replication is a somewhat retrofitted feature in many databases, there are often subtle configuration pitfalls and surprising interactions with other database features. For example, autoincrementing keys, triggers, and integrity constraints can be problematic. For this reason, multi-leader replication is often considered dangerous territory that should be avoided if possible",
            "color": "yellow",
            "note": "Retrofitted = add on",
            "chapter": null
        },
        {
            "id": 992,
            "is_deleted": false,
            "representative_text": "example, if you decode a database value into model objects in the application, and later reencode those model objects, the unknown field might be lost in that translation process. Solving this is not a hard problem; you just need to be aware of it. ",
            "selected_text": "and later reencode those model objects, the unknown field might be lost in that translation process. Solving this is not a hard problem; you just need to be aware of it. ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 993,
            "is_deleted": false,
            "representative_text": "For example, consider the calendar apps on your mobile phone, your laptop, and other devices. You need to be able to see your meetings (make read requests) and enter new meetings (make write requests) at any time, regardless of whether your device currently has an internet connection. If you make any changes while you are offline, they need to be synced with a server and your other devices when the device is next online. In this case, every device has a local database that acts as a leader (it accepts write requests), and there is an asynchronous multi-leader replication process (sync) between the replicas of your calendar on all of your devices. The replication lag may be hours or even days, depending on when you have internet access available. ",
            "selected_text": "For example, consider the calendar apps on your mobile phone, your laptop, and other devices. You need to be able to see your meetings (make read requests) and enter new meetings (make write requests) at any time, regardless of whether your device currently has an internet connection. If you make any changes while you are offline, they need to be synced with a server and your other devices when the device is next online. In this case, every device has a local database that acts as a leader (it accepts write requests), and there is an asynchronous multi-leader replication process (sync) between the replicas of your calendar on all of your devices. The replication lag may be hours or even days, depending on when you have internet access available.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 994,
            "is_deleted": false,
            "representative_text": "RESTful APIs tend to favor simpler approaches, typically involving less code generation and automated tooling. ",
            "selected_text": "RESTful APIs tend to favor simpler approaches, typically involving less code generation and automated tooling",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 995,
            "is_deleted": false,
            "representative_text": "In practice, if you enable synchronous replication on a database, it usually means that one of the followers is synchronous, and the others are asynchronous. If the synchronous follower becomes unavailable or slow, one of the asynchronous followers is made synchronous. This guarantees that you have an up-to-date copy of the data on at least two nodes: the leader and one synchronous follower. This configuration is sometimes also called semi-synchronous [7]. ",
            "selected_text": "In practice, if you enable synchronous replication on a database, it usually means that one of the followers is synchronous, and the others are asynchronous. If the synchronous follower becomes unavailable or slow, one of the asynchronous followers is made synchronous. This guarantees that you have an up-to-date copy of the data on at least two nodes: the leader and one synchronous follower. This configuration is sometimes also called semi-synchronous [7].",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 996,
            "is_deleted": false,
            "representative_text": "Often, leader-based replication is configured to be completely asynchronous. In this case, if the leader fails and is not recoverable, any writes that have not yet been replicated to followers are lost. This means that a write is not guaranteed to be durable, even if it has been confirmed to the client. However, a fully asynchronous configuration has the advantage that the leader can continue processing writes, even if all of its followers have fallen behind. ",
            "selected_text": "Often, leader-based replication is configured to be completely asynchronous. In this case, if the leader fails and is not recoverable, any writes that have not yet been replicated to followers are lost. This means that a write is not guaranteed to be durable, even if it has been confirmed to the client. However, a fully asynchronous configuration has the advantage that the leader can continue processing writes, even if all of its followers have fallen behind.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 997,
            "is_deleted": false,
            "representative_text": "construct manually, users of SOAP rely heavily on tool support, code generation, and IDEs [38]. ",
            "selected_text": "users of SOAP rely heavily on tool support, code generation, and IDEs ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 998,
            "is_deleted": false,
            "representative_text": "For RESTful APIs, common approaches are to use a version number in the URL or in the HTTP Accept header. ",
            "selected_text": "For RESTful APIs, common approaches are to use a version number in the URL or in the HTTP Accept header",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 999,
            "is_deleted": false,
            "representative_text": "Preventing this kind of anomaly requires another type of guarantee: consistent prefix reads [23]. This guarantee says that if a sequence of writes happens in a certain order, then anyone reading those writes will see them appear in the same order. ",
            "selected_text": "Preventing this kind of anomaly requires another type of guarantee: consistent prefix reads [23]. This guarantee says that if a sequence of writes happens in a certain order, then anyone reading those writes will see them appear in the same order",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1000,
            "is_deleted": false,
            "representative_text": "Some data storage systems take a different approach, abandoning the concept of a leader and allowing any replica to directly accept writes from clients. ",
            "selected_text": "Some data storage systems take a different approach, abandoning the concept of a leader and allowing any replica to directly accept writes from clients",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1001,
            "is_deleted": false,
            "representative_text": "Although this approach is popular, it is dangerously prone to data loss [35]. ",
            "selected_text": "Although this approach is popular, it is dangerously prone to data loss [35].",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1003,
            "is_deleted": false,
            "representative_text": "It makes no promises about other users: other users' updates may not be visible until some later time. However, it reassures the user that their own input has been saved correctly. ",
            "selected_text": "other users' updates may not be visible until some later time. However, it reassures the user that their own input has been saved correctly.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1004,
            "is_deleted": false,
            "representative_text": "In this situation, we need read-after-write consistency, also known as read-your-writes consistency [24]. This is a guarantee that if the user reloads the page, they will always see any updates they submitted themselves. ",
            "selected_text": "read-your-writes consistency [24]. This is a guarantee that if the user reloads the page, they will always see any updates they submitted themselves.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1006,
            "is_deleted": false,
            "representative_text": "This is a particular problem in partitioned (sharded) databases, which we will discuss in Chapter 6. ",
            "selected_text": "This is a particular problem in partitioned (sharded) databases",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1007,
            "is_deleted": false,
            "representative_text": "picked based on geographic proximity to the user), but from any one user's point of view the configuration is essentially single-leader. ",
            "selected_text": "but from any one user's point of view the configuration is essentially single-leader.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1008,
            "is_deleted": false,
            "representative_text": "densely connected topology (such as all-to-all) is better because it allows messages to travel along different paths, avoiding a single point of failure. ",
            "selected_text": "better because it allows messages to travel along different paths, avoiding a single point of failure.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1009,
            "is_deleted": false,
            "representative_text": "In a multi-leader configuration, there is no defined ordering of writes, so it's not clear what the final value should be. ",
            "selected_text": "In a multi-leader configuration, there is no defined ordering of writes, so it's not clear what the final value should be",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1010,
            "is_deleted": false,
            "representative_text": "The application may prompt the user or automatically resolve the conflict, and write the result back to the database. CouchDB works this way, for example. ",
            "selected_text": "application may prompt the user or automatically resolve the conflict, and write the result back to the database. CouchDB works this way, for example",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1011,
            "is_deleted": false,
            "representative_text": "Thus, the database must resolve the conflict in a convergent way, which means that all replicas must arrive at the same final value when all changes have been replicated. ",
            "selected_text": "the database must resolve the conflict in a convergent way, which means that all replicas must arrive at the same final value when all changes have been replicated.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1013,
            "is_deleted": false,
            "representative_text": "On the other hand, in a leaderless configuration, failover does not exist. ",
            "selected_text": "On the other hand, in a leaderless configuration, failover does not exist",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1014,
            "is_deleted": false,
            "representative_text": "one replica: read requests are also sent to several nodes in parallel. ",
            "selected_text": "read requests are also sent to several nodes in parallel.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1015,
            "is_deleted": false,
            "representative_text": "In this situation, it's likely that fewer than w or r reachable nodes remain, so the client can no longer reach a quorum. ",
            "selected_text": "In this situation, it's likely that fewer than w or r reachable nodes remain, so the client can no longer reach a quorum.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1017,
            "is_deleted": false,
            "representative_text": "A multi-leader configuration with asynchronous replication can usually tolerate network problems better: a temporary network interruption does not prevent writes being processed. ",
            "selected_text": "A multi-leader configuration with asynchronous replication can usually tolerate network problems better: a temporary network interruption does not prevent writes being processed",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1018,
            "is_deleted": false,
            "representative_text": "Each write from a client is sent to all replicas, regardless of datacenter, but the client usually only waits for acknowledgment from a quorum of nodes within its local datacenter so that it is unaffected by delays and interruptions on the cross-datacenter link. ",
            "selected_text": "Each write from a client is sent to all replicas, regardless of datacenter, but the client usually only waits for acknowledgment from a quorum of nodes within its local datacenter so that it is unaffected by delays and interruptions on the cross-datacenter link",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1020,
            "is_deleted": false,
            "representative_text": "The client sees that replica 3 has a stale value and writes the newer value back to that replica. This approach works well for values that are frequently read. ",
            "selected_text": "The client sees that replica 3 has a stale value and writes the newer value back to that replica. This approach works well for values that are frequently read.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1021,
            "is_deleted": false,
            "representative_text": "In addition, some datastores have a background process that constantly looks for differences in the data between replicas and copies any missing data from one replica to another. ",
            "selected_text": "background process that constantly looks for differences in the data between replicas and copies any missing data from one replica to another",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1022,
            "is_deleted": false,
            "representative_text": "database (e.g., UPDATE ... WHERE <some condition>), they must be executed in exactly the same order on each replica, or else they may have a different effect. ",
            "selected_text": "they must be executed in exactly the same order on each replica",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1023,
            "is_deleted": false,
            "representative_text": "In Dynamo-style databases, the parameters n, w, and r are typically configurable. A common choice is to make n an odd number (typically 3 or 5) and to set w = r = (n + 1) / 2 (rounded up). ",
            "selected_text": "In Dynamo-style databases, the parameters n, w, and r are typically configurable. A common choice is to make n an odd number (typically 3 or 5) and to set w = r = (n + 1) / 2 (rounded up",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1026,
            "is_deleted": false,
            "representative_text": "The parameters w and r allow you to adjust the probability of stale values being read, but it's wise to not take them as absolute guarantees. ",
            "selected_text": "The parameters w and r allow you to adjust the probability of stale values being read, but it's wise to not take them as absolute guarantees.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1027,
            "is_deleted": false,
            "representative_text": "Thus, the inter-datacenter network delay is hidden from users, which means the perceived performance may be better. ",
            "selected_text": "Thus, the inter-datacenter network delay is hidden from users, which means the perceived performance may be better",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1028,
            "is_deleted": false,
            "representative_text": "These characteristics make databases with leaderless replication appealing for use cases that require high availability and low latency, and that can tolerate occasional stale reads. ",
            "selected_text": "These characteristics make databases with leaderless replication appealing for use cases that require high availability and low latency, and that can tolerate occasional stale reads.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1029,
            "is_deleted": false,
            "representative_text": "replication log in leader-based replication, this anti-entropy process does not copy writes in any particular order, and there may be a significant delay before data is copied. ",
            "selected_text": "does not copy writes in any particular order",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1030,
            "is_deleted": false,
            "representative_text": "By subtracting a follower's current position from the leader's current position, you can measure the amount of replication lag. ",
            "selected_text": "By subtracting a follower's current position from the leader's current position, you can measure the amount of replication lag.",
            "color": "yellow",
            "note": "Calculate lag for leader based replication.",
            "chapter": null
        },
        {
            "id": 1033,
            "is_deleted": false,
            "representative_text": "This algorithm ensures that no data is silently dropped, but it unfortunately requires that the clients do some extra work: if several operations happen concurrently, clients have to clean up afterward by merging the concurrently written values. ",
            "selected_text": "but it unfortunately requires that the clients do some extra work: if several operations happen concurrently, clients have to clean up afterward by merging the concurrently written values",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1034,
            "is_deleted": false,
            "representative_text": "in fact, it is not important whether they literally overlap in time. Because of problems with clocks in distributed systems, it is actually quite difficult to tell whether two things happened at exactly the same time--an issue we will discuss in more detail in Chapter 8. ",
            "selected_text": "it is not important whether they literally overlap in time. Because of problems with clocks in distributed systems, it is actually quite difficult to tell whether two things happened at exactly the same time",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1035,
            "is_deleted": false,
            "representative_text": "Thus, you also need some way of keeping track of which keys are being split. ",
            "selected_text": "you also need some way of keeping track of which keys are being split.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1036,
            "is_deleted": false,
            "representative_text": "Our goal with partitioning is to spread the data and the query load evenly across nodes. ",
            "selected_text": "Our goal with partitioning is to spread the data and the query load evenly across nodes.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1037,
            "is_deleted": false,
            "representative_text": "Most database vendors recommend that you structure your partitioning scheme so that secondary index queries can be served from a single partition, but that is not always possible, especially when you're using multiple secondary indexes in a single query (such as filtering cars by color and by make at the same time). ",
            "selected_text": "Most database vendors recommend that you structure your partitioning scheme so that secondary index queries can be served from a single partition",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1038,
            "is_deleted": false,
            "representative_text": "However, if you want to allow people to also remove things from their carts, and not just add things, then taking the union of siblings may not yield the right result: if you merge two sibling carts and an item has been removed in only one of them, then the removed item will reappear in the union of the siblings [37]. ",
            "selected_text": "However, if you want to allow people to also remove things from their carts, and not just add things, then taking the union of siblings may not yield the right result: if you merge two sibling carts and an item has been removed in only one of them, then the removed item will reappear in the union of the siblings",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1039,
            "is_deleted": false,
            "representative_text": "A global index must also be partitioned, but it can be partitioned differently from the primary key index. ",
            "selected_text": "A global index must also be partitioned, but it can be partitioned differently from the primary key index",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1040,
            "is_deleted": false,
            "representative_text": "We call this kind of index term-partitioned, because the term we're looking for determines the partition of the index. ",
            "selected_text": "We call this kind of index term-partitioned, because the term we're looking for determines the partition of the index",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1041,
            "is_deleted": false,
            "representative_text": "We also say that B is causally dependent on A. ",
            "selected_text": "We also say that B is causally dependent on A.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1042,
            "is_deleted": false,
            "representative_text": "Unfortunately however, by using the hash of the key for partitioning we lose a nice property of key-range partitioning: the ability to do efficient range queries. Keys that were once adjacent are now scattered across all the partitions, so their sort order is lost. ",
            "selected_text": "Unfortunately however, by using the hash of the key for partitioning we lose a nice property of key-range partitioning: the ability to do efficient range queries. Keys that were once adjacent are now scattered across all the partitions, so their sort order is lost",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1044,
            "is_deleted": false,
            "representative_text": "The main reason for wanting to partition data is scalability. Different partitions can be placed on different nodes in a shared-nothing cluster (see the introduction to Part II for a definition of shared nothing). ",
            "selected_text": "The main reason for wanting to partition data is scalability. Different partitions can be placed on different nodes in a shared-nothing cluster",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1045,
            "is_deleted": false,
            "representative_text": "The only safe way of using a database with LWW is to ensure that a key is only written once and thereafter treated as immutable, thus avoiding any concurrent updates to the same key. For example, a recommended way of using Cassandra is to use a UUID as the key, thus giving each write operation a unique key [53]. ",
            "selected_text": "The only safe way of using a database with LWW is to ensure that a key is only written once and thereafter treated as immutable, thus avoiding any concurrent updates to the same key. For example, a recommended way of using Cassandra is to use a UUID as the key, thus giving each write operation a unique key",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1046,
            "is_deleted": false,
            "representative_text": "A simple approach is to just pick one of the values based on a version number or timestamp (last write wins), but that implies losing data. ",
            "selected_text": "A simple approach is to just pick one of the values based on a version number or timestamp (last write wins), but that implies losing data",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1047,
            "is_deleted": false,
            "representative_text": "The collection of version numbers from all the replicas is called a version vector [56]. ",
            "selected_text": "The collection of version numbers from all the replicas is called a version vector",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1048,
            "is_deleted": false,
            "representative_text": "If partitions are very large, rebalancing and recovery from node failures become expensive. But if partitions are too small, they incur too much overhead. The best performance is achieved when the size of partitions is \"just right,\" neither too big nor too small, which can be hard to achieve if the number of partitions is fixed but the dataset size varies. ",
            "selected_text": "If partitions are very large, rebalancing and recovery from node failures become expensive. But if partitions are too small, they incur too much overhead. The best performance is achieved when the size of partitions is \"just right,\" neither too big nor too small, which can be hard to achieve if the number of partitions is fixed but the dataset size varies.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1049,
            "is_deleted": false,
            "representative_text": "If one operation happened before another, the later operation should overwrite the earlier operation, but if the operations are concurrent, we have a conflict that needs to be resolved. ",
            "selected_text": "If one operation happened before another, the later operation should overwrite the earlier operation, but if the operations are concurrent, we have a conflict that needs to be resolved",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1050,
            "is_deleted": false,
            "representative_text": "Just a two-digit decimal random number would split the writes to the key evenly across 100 different keys, allowing those keys to be distributed to different partitions. However, having split the writes across different keys, any reads now have to do additional work, as they have to read the data from all 100 keys and combine it. ",
            "selected_text": "Just a two-digit decimal random number would split the writes to the key evenly across 100 different keys, allowing those keys to be distributed to different partitions. However, having split the writes across different keys, any reads now have to do additional work, as they have to read the data from all 100 keys and combine it",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1051,
            "is_deleted": false,
            "representative_text": "Partitioning is usually combined with replication so that copies of each partition are stored on multiple nodes. This means that, even though each record belongs to exactly one partition, it may still be stored on several different nodes for fault tolerance. ",
            "selected_text": "Partitioning is usually combined with replication so that copies of each partition are stored on multiple nodes. This means that, even though each record belongs to exactly one partition, it may still be stored on several different nodes for fault tolerance",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1052,
            "is_deleted": false,
            "representative_text": "The process of moving load from one node in the cluster to another is called rebalancing. ",
            "selected_text": "The process of moving load from one node in the cluster to another is called rebalancing",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1053,
            "is_deleted": false,
            "representative_text": "Because of this risk of skew and hot spots, many distributed datastores use a hash function to determine the partition for a given key. ",
            "selected_text": "Because of this risk of skew and hot spots, many distributed datastores use a hash function to determine the partition for a given key.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1054,
            "is_deleted": false,
            "representative_text": "The advantage of a global (term-partitioned) index over a document-partitioned index is that it can make reads more efficient: rather than doing scatter/gather over all partitions, a client only needs to make a request to the partition containing the term that it wants. However, the downside of a global index is that writes are slower and more complicated, because a write to a single document may now affect multiple partitions of the index (every term in the document might be on a different partition, on a different node). ",
            "selected_text": "The advantage of a global (term-partitioned) index over a document-partitioned index is that it can make reads more efficient: rather than doing scatter/gather over all partitions, a client only needs to make a request to the partition containing the term that it wants. However, the downside of a global index is that writes are slower and more complicated, because a write to a single document may now affect multiple partitions of the index",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1055,
            "is_deleted": false,
            "representative_text": "Rather than each partition having its own secondary index (a local index), we can construct a global index that covers data in all partitions. ",
            "selected_text": "Rather than each partition having its own secondary index (a local index), we can construct a global index that covers data in all partitions.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1056,
            "is_deleted": false,
            "representative_text": "Consistent hashing, as defined by Karger et al. [7], is a way of evenly distributing load across an internet-wide system of caches such as a content delivery network (CDN). It uses randomly chosen partition boundaries to avoid the need for central control or distributed consensus. Note that consistent here has nothing to do with replica consistency (see Chapter 5) or ACID consistency (see Chapter 7), but rather describes a particular approach to rebalancing. ",
            "selected_text": "Consistent hashing, as defined by Karger et al. [7], is a way of evenly distributing load across an internet-wide system of caches such as a content delivery network (CDN). It uses randomly chosen partition boundaries to avoid the need for central control or distributed consensus. Note that consistent here has nothing to do with replica consistency (see Chapter 5) or ACID consistency (see Chapter 7), but rather describes a particular approach to rebalancing.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1058,
            "is_deleted": false,
            "representative_text": "Thus, if you want to search for red cars, you need to send the query to all partitions, and combine all the results you get back. ",
            "selected_text": "Thus, if you want to search for red cars, you need to send the query to all partitions, and combine all the results you get back",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1059,
            "is_deleted": false,
            "representative_text": "this problem, an item cannot simply be deleted from the database when it is removed; instead, the system must leave a marker with an appropriate version number to indicate that the item has been removed when merging siblings. Such a deletion marker is known as a tombstone. ",
            "selected_text": "instead, the system must leave a marker with an appropriate version number to indicate that the item has been removed when merging siblings. Such a deletion marker is known as a tombstone",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1060,
            "is_deleted": false,
            "representative_text": "Normally, partitions are defined in such a way that each piece of data (each record, row, or document) belongs to exactly one partition. ",
            "selected_text": "Normally, partitions are defined in such a way that each piece of data (each record, row, or document) belongs to exactly one partition",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1061,
            "is_deleted": false,
            "representative_text": "With the example of a shopping cart, a reasonable approach to merging siblings is to just take the union. ",
            "selected_text": "With the example of a shopping cart, a reasonable approach to merging siblings is to just take the union",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1062,
            "is_deleted": false,
            "representative_text": "If a node is removed from the cluster, the same happens in reverse. Only entire partitions are moved between nodes. The number of partitions does not change, nor does the assignment of keys to partitions. ",
            "selected_text": "If a node is removed from the cluster, the same happens in reverse. Only entire partitions are moved between nodes. The number of partitions does not change, nor does the assignment of keys to partitions",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1063,
            "is_deleted": false,
            "representative_text": "We need an approach that doesn't move data around more than necessary. ",
            "selected_text": "We need an approach that doesn't move data around more than necessary",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1064,
            "is_deleted": false,
            "representative_text": "A secondary index usually doesn't identify a record uniquely but rather is a way of searching for occurrences of a particular value: find all actions by user 123, find all articles containing the word hogwash, find all cars whose color is red, and so on. ",
            "selected_text": "A secondary index usually doesn't identify a record uniquely but rather is a way of searching for occurrences of a particular value",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1065,
            "is_deleted": false,
            "representative_text": "Cassandra achieves a compromise between the two partitioning strategies [11, 12, 13]. A table in Cassandra can be declared with a compound primary key consisting of several columns. Only the first part of that key is hashed to determine the partition, but the other columns are used as a concatenated index for sorting the data in Cassandra's SSTables. A query therefore cannot search for a range of values within the first column of a compound key, but if it specifies a fixed value for the first column, it can perform an efficient range scan over the other columns of the key. The concatenated index approach enables an elegant data model for one-to-many relationships. For example, on a social media site, one user may post many updates. If the primary key for updates is chosen to be (user_id, update_timestamp), then you can efficiently retrieve all updates made by a particular user within some time interval, sorted by timestamp. Different users may be stored on different partitions, but within each user, the updates are stored ordered by timestamp on a single partition. ",
            "selected_text": "Cassandra achieves a compromise between the two partitioning strategies [11, 12, 13]. A table in Cassandra can be declared with a compound primary key consisting of several columns. Only the first part of that key is hashed to determine the partition, but the other columns are used as a concatenated index for sorting the data in Cassandra's SSTables. A query therefore cannot search for a range of values within the first column of a compound key, but if it specifies a fixed value for the first column, it can perform an efficient range scan over the other columns of the key. The concatenated index approach enables an elegant data model for one-to-many relationships. For example, on a social media site, one user may post many updates. If the primary key for updates is chosen to be (user_id, update_timestamp), then you can efficiently retrieve all updates made by a particular user within some time interval, sorted by timestamp. Different users may be stored on different partitions, but within each user, the updates are stored ordered by timestamp on a single partition.",
            "color": "yellow",
            "note": "This is what we did for performing range queries on model history.. we store a pair of session id and timestamp as composite key. The timestamp is used for maintaining the sorted order of the conversation and the session id is used for the hash. This allows us to perform efficient range queries since we have a one to many model.",
            "chapter": null
        },
        {
            "id": 1066,
            "is_deleted": false,
            "representative_text": "Even if the input strings are very similar, their hashes are evenly distributed across that range of numbers. ",
            "selected_text": "Even if the input strings are very similar, their hashes are evenly distributed across that range of numbers.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1067,
            "is_deleted": false,
            "representative_text": "Now, if a node is added to the cluster, the new node can steal a few partitions from every existing node until partitions are fairly distributed once again. ",
            "selected_text": "Now, if a node is added to the cluster, the new node can steal a few partitions from every existing node until partitions are fairly distributed once again",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1068,
            "is_deleted": false,
            "representative_text": "The presence of skew makes partitioning much less effective. In an extreme case, all the load could end up on one partition, so 9 out of 10 nodes are idle and your bottleneck is the single busy node. A partition with disproportionately high load is called a hot spot. ",
            "selected_text": "The presence of skew makes partitioning much less effective. In an extreme case, all the load could end up on one partition, so 9 out of 10 nodes are idle and your bottleneck is the single busy node. A partition with disproportionately high load is called a hot spot.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1070,
            "is_deleted": false,
            "representative_text": "Isolation in the sense of ACID means that concurrently executing transactions are isolated from each other: they cannot step on each other's toes. The classic database textbooks formalize isolation as serializability, which means that each transaction can pretend that it is the only transaction running on the entire database. ",
            "selected_text": "Isolation in the sense of ACID means that concurrently executing transactions are isolated from each other: they cannot step on each other's toes. The classic database textbooks formalize isolation as serializability, which means that each transaction can pretend that it is the only transaction running on the entire database.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1071,
            "is_deleted": false,
            "representative_text": "In general, atomic refers to something that cannot be broken down into smaller parts. ",
            "selected_text": "In general, atomic refers to something that cannot be broken down into smaller parts",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1072,
            "is_deleted": false,
            "representative_text": "The purpose of a database system is to provide a safe place where data can be stored without fear of losing it. Durability is the promise that once a transaction has committed successfully, any data it has written will not be forgotten, even if there is a hardware fault or the database crashes. ",
            "selected_text": "The purpose of a database system is to provide a safe place where data can be stored without fear of losing it. Durability is the promise that once a transaction has committed successfully, any data it has written will not be forgotten, even if there is a hardware fault or the database crashes. ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1073,
            "is_deleted": false,
            "representative_text": "When reading from the database, you will only see data that has been committed (no dirty reads). ",
            "selected_text": "When reading from the database, you will only see data that has been committed (no dirty reads).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1074,
            "is_deleted": false,
            "representative_text": "To implement snapshot isolation, databases use a generalization of the mechanism we saw for preventing dirty reads in Figure 7-4. ",
            "selected_text": "To implement snapshot isolation, databases use a generalization of the mechanism we saw for preventing dirty reads",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1075,
            "is_deleted": false,
            "representative_text": "However, you might find this query to be too slow if there are many emails, and decide to store the number of unread messages in a separate field (a kind of denormalization). ",
            "selected_text": "you might find this query to be too slow if there are many emails, and decide to store the number of unread messages in a separate field (a kind of denormalization",
            "color": "yellow",
            "note": "By demoralizing, you agree to store redundant data to answer some queries in less time.",
            "chapter": null
        },
        {
            "id": 1076,
            "is_deleted": false,
            "representative_text": "Imagine a transaction has written some data to the database, but the transaction has not yet committed or aborted. Can another transaction see that uncommitted data? If yes, that is called a dirty read [2]. ",
            "selected_text": "Imagine a transaction has written some data to the database, but the transaction has not yet committed or aborted. Can another transaction see that uncommitted data? If yes, that is called a dirty read",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1077,
            "is_deleted": false,
            "representative_text": "The idea is that each transaction reads from a consistent snapshot of the database--that is, the transaction sees all the data that was committed in the database at the start of the transaction. ",
            "selected_text": "The idea is that each transaction reads from a consistent snapshot of the database--that is, the transaction sees all the data that was committed in the database at the start of the transaction",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1078,
            "is_deleted": false,
            "representative_text": "For example, in Figure 7-2, the user sees the new unread email but not the updated counter. This is a dirty read of the email. Seeing the database in a partially updated state is confusing to users and may cause other transactions to take incorrect decisions. ",
            "selected_text": "For example, in Figure 7-2, the user sees the new unread email but not the updated counter. This is a dirty read of the email. Seeing the database in a partially updated state is confusing to users and may cause other transactions to take incorrect decisions.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1079,
            "is_deleted": false,
            "representative_text": "If a database only needed to provide read committed isolation, but not snapshot isolation, it would be sufficient to keep two versions of an object: the committed version and the overwritten-but-not-yet-committed version. However, storage engines that support snapshot isolation typically use MVCC for their read committed isolation level as well. A typical approach is that read committed uses a separate snapshot for each query, while snapshot isolation uses the same snapshot for an entire transaction. ",
            "selected_text": "If a database only needed to provide read committed isolation, but not snapshot isolation, it would be sufficient to keep two versions of an object: the committed version and the overwritten-but-not-yet-committed version. However, storage engines that support snapshot isolation typically use MVCC for their read committed isolation level as well. A typical approach is that read committed uses a separate snapshot for each query, while snapshot isolation uses the same snapshot for an entire transaction",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1080,
            "is_deleted": false,
            "representative_text": "completed (committed) due to a fault, then the transaction is aborted and the database must discard or undo any writes it has made so far in that transaction. ",
            "selected_text": "database must discard or undo any writes it has made so far in that transaction.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1081,
            "is_deleted": false,
            "representative_text": "Transactions running at the read committed isolation level must prevent dirty writes, usually by delaying the second write until the first write's transaction has committed or aborted. ",
            "selected_text": "Transactions running at the read committed isolation level must prevent dirty writes, usually by delaying the second write until the first write's transaction has committed or aborted. ",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1082,
            "is_deleted": false,
            "representative_text": "However, the approach of requiring read locks does not work well in practice, because one long-running write transaction can force many read-only transactions to wait until the long-running transaction has completed. ",
            "selected_text": "However, the approach of requiring read locks does not work well in practice, because one long-running write transaction can force many read-only transactions to wait until the long-running transaction has completed",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1083,
            "is_deleted": false,
            "representative_text": "pretend that no concurrency is happening: serializable isolation means that the database guarantees that transactions have the same effect as if they ran serially (i.e., one at a time, without any concurrency). ",
            "selected_text": "serializable isolation means that the database guarantees that transactions have the same effect as if they ran serially (i.e., one at a time, without any concurrency).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1084,
            "is_deleted": false,
            "representative_text": "Concurrency bugs are hard to find by testing, because such bugs are only triggered when you get unlucky with the timing. Such timing issues might occur very rarely, and are usually difficult to reproduce. ",
            "selected_text": "Concurrency bugs are hard to find by testing, because such bugs are only triggered when you get unlucky with the timing. Such timing issues might occur very rarely, and are usually difficult to reproduce",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1085,
            "is_deleted": false,
            "representative_text": "When writing to the database, you will only overwrite data that has been committed (no dirty writes). ",
            "selected_text": "When writing to the database, you will only overwrite data that has been committed (no dirty writes).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1086,
            "is_deleted": false,
            "representative_text": "If an error occurs halfway through a sequence of writes, the transaction should be aborted, and the writes made up to that point should be discarded. ",
            "selected_text": "If an error occurs halfway through a sequence of writes, the transaction should be aborted, and the writes made up to that point should be discarded",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1087,
            "is_deleted": false,
            "representative_text": "prevent dirty reads using the approach illustrated in Figure 7-4: for every object that is written, the database remembers both the old committed value and the new value set by the transaction that currently holds the write lock. While the transaction is ongoing, any other transactions that read the object are simply given the old value. ",
            "selected_text": "for every object that is written, the database remembers both the old committed value and the new value set by the transaction that currently holds the write lock. While the transaction is ongoing, any other transactions that read the object are simply given the old value.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1088,
            "is_deleted": false,
            "representative_text": "Rather, ACID atomicity describes what happens if a client wants to make several writes, but a fault occurs after some of the writes have been processed--for example, a process crashes, a network connection is interrupted, a disk becomes full, or some integrity constraint is violated. ",
            "selected_text": "ACID atomicity describes what happens if a client wants to make several writes, but a fault occurs after some of the writes have been processed",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1089,
            "is_deleted": false,
            "representative_text": "Only one transaction can hold the lock for any given object; if another transaction wants to write to the same object, it must wait until the first transaction is committed or aborted before it can acquire the lock and continue. This locking is done automatically by databases in read committed mode (or stronger isolation levels). ",
            "selected_text": "Only one transaction can hold the lock for any given object; if another transaction wants to write to the same object, it must wait until the first transaction is committed or aborted before it can acquire the lock and continue. This locking is done automatically by databases in read committed mode (or stronger isolation levels).",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1090,
            "is_deleted": false,
            "representative_text": "A transaction is a way for an application to group several reads and writes together into a logical unit. Conceptually, all the reads and writes in a transaction are executed as one operation: either the entire transaction succeeds (commit) or it fails (abort, rollback). If it fails, the application can safely retry. ",
            "selected_text": "A transaction is a way for an application to group several reads and writes together into a logical unit. Conceptually, all the reads and writes in a transaction are executed as one operation: either the entire transaction succeeds (commit) or it fails (abort, rollback). If it fails, the application can safely retry",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1091,
            "is_deleted": false,
            "representative_text": "having to worry about partial failure, by giving an all-or-nothing guarantee. ",
            "selected_text": "all-or-nothing guarantee.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1092,
            "is_deleted": false,
            "representative_text": "(Systems that do not meet the ACID criteria are sometimes called BASE, which stands for Basically Available, Soft state, and Eventual consistency [9]. This is even more vague than the definition of ACID. It seems that the only sensible definition of BASE is \"not ACID\"; i.e., it can mean almost anything you want.) ",
            "selected_text": "Systems that do not meet the ACID criteria are sometimes called BASE, which stands for Basically Available, Soft state, and Eventual consistency [9]. This is even more vague than the definition of ACID. It seems that the only sensible definition of BASE is \"not ACID\"; i.e., it can mean almost anything you want.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1094,
            "is_deleted": false,
            "representative_text": "Rather than blindly relying on tools, we need to develop a good understanding of the kinds of concurrency problems that exist, and how to prevent them. Then we can build applications that are reliable and correct, using the tools at our disposal. ",
            "selected_text": "Rather than blindly relying on tools, we need to develop a good understanding of the kinds of concurrency problems that exist, and how to prevent them. Then we can build applications that are reliable and correct, using the tools at our disposal.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1096,
            "is_deleted": false,
            "representative_text": "Concurrently running transactions shouldn't interfere with each other. ",
            "selected_text": "Concurrently running transactions shouldn't interfere with each other.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1098,
            "is_deleted": false,
            "representative_text": "The safety guarantees provided by transactions are often described by the well-known acronym ACID, which stands for Atomicity, Consistency, Isolation, and Durability. ",
            "selected_text": "The safety guarantees provided by transactions are often described by the well-known acronym ACID, which stands for Atomicity, Consistency, Isolation, and Durability",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1101,
            "is_deleted": false,
            "representative_text": "concurrently--in other words, the database prevents all possible race conditions. ",
            "selected_text": "the database prevents all possible race conditions.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1102,
            "is_deleted": false,
            "representative_text": "In the previous sections we saw dirty writes and lost updates, two kinds of race conditions that can occur when different transactions concurrently try to write to the same objects. ",
            "selected_text": "dirty writes and lost updates, two kinds of race conditions that can occur when different transactions concurrently try to write to the same objects.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1103,
            "is_deleted": false,
            "representative_text": "Write skew can occur if two transactions read the same objects, and then update some of those objects (different transactions may update different objects). ",
            "selected_text": "Write skew can occur if two transactions read the same objects, and then update some of those objects",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1105,
            "is_deleted": false,
            "representative_text": "Then the application can perform a read-modify-write cycle, and if any other transaction tries to concurrently read the same object, it is forced to wait until the first read-modify-write cycle has completed. ",
            "selected_text": "if any other transaction tries to concurrently read the same object, it is forced to wait until the first read-modify-write cycle has completed.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1111,
            "is_deleted": false,
            "representative_text": "Serializable isolation is usually regarded as the strongest isolation level. It guarantees that even though transactions may execute in parallel, the end result is the same as if they had executed one at a time, serially, without any concurrency. ",
            "selected_text": "Serializable isolation is usually regarded as the strongest isolation level. It guarantees that even though transactions may execute in parallel, the end result is the same as if they had executed one at a time, serially, without any concurrency",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1115,
            "is_deleted": false,
            "representative_text": "An alternative is to allow them to execute in parallel and, if the transaction manager detects a lost update, abort the transaction and force it to retry its read-modify-write cycle. ",
            "selected_text": "An alternative is to allow them to execute in parallel and, if the transaction manager detects a lost update, abort the transaction and force it to retry its read-modify-write cycle.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1117,
            "is_deleted": false,
            "representative_text": "If the current value does not match what you previously read, the update has no effect, and the read-modify-write cycle must be retried. ",
            "selected_text": "If the current value does not match what you previously read, the update has no effect, and the read-modify-write cycle must be retried.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1118,
            "is_deleted": false,
            "representative_text": "avoid lost updates by allowing an update to happen only if the value has not changed since you last read it. ",
            "selected_text": "by allowing an update to happen only if the value has not changed since you last read it",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1120,
            "is_deleted": false,
            "representative_text": "An advantage of this approach is that databases can perform this check efficiently in conjunction with snapshot isolation. ",
            "selected_text": "An advantage of this approach is that databases can perform this check efficiently in conjunction with snapshot isolation",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1128,
            "is_deleted": false,
            "representative_text": "isn't used to store information about the booking--it's purely a collection of locks which is used to prevent bookings on the same room and time range from being modified concurrently. ",
            "selected_text": "purely a collection of locks which is used to prevent bookings on the same room and time range from being modified concurrently",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1129,
            "is_deleted": false,
            "representative_text": "The lost update problem can occur if an application reads some value from the database, modifies it, and writes back the modified value (a read-modify-write cycle). If two transactions do this concurrently, one of the modifications can be lost, because the second write does not include the first modification. ",
            "selected_text": "The lost update problem can occur if an application reads some value from the database, modifies it, and writes back the modified value (a read-modify-write cycle). If two transactions do this concurrently, one of the modifications can be lost, because the second write does not include the first modification",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1130,
            "is_deleted": false,
            "representative_text": "If you can't use a serializable isolation level, the second-best option in this case is probably to explicitly lock the rows that the transaction depends on. ",
            "selected_text": "the second-best option in this case is probably to explicitly lock the rows that the transaction depends on",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1132,
            "is_deleted": false,
            "representative_text": "This approach is called materializing conflicts, because it takes a phantom and turns it into a lock conflict on a concrete set of rows that exist in the database [11]. ",
            "selected_text": "This approach is called materializing conflicts, because it takes a phantom and turns it into a lock conflict on a concrete set of rows that exist in the database",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1135,
            "is_deleted": false,
            "representative_text": "error-prone to figure out how to materialize conflicts, and it's ugly to let a concurrency control mechanism leak into the application data model. For those reasons, materializing conflicts should be considered a last resort if no alternative is possible. ",
            "selected_text": "it's ugly to let a concurrency control mechanism leak into the application data model. For those reasons, materializing conflicts should be considered a last resort if no alternative is possible",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1138,
            "is_deleted": false,
            "representative_text": "Another option is to simply force all atomic operations to be executed on a single thread. ",
            "selected_text": "Another option is to simply force all atomic operations to be executed on a single thread.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1144,
            "is_deleted": false,
            "representative_text": "This effect, where a write in one transaction changes the result of a search query in another transaction, is called a phantom [3]. ",
            "selected_text": "This effect, where a write in one transaction changes the result of a search query in another transaction, is called a phantom",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1147,
            "is_deleted": false,
            "representative_text": "Instead, as discussed in \"Detecting Concurrent Writes\", a common approach in such replicated databases is to allow concurrent writes to create several conflicting versions of a value (also known as siblings), and to use application code or special data structures to resolve and merge these versions after the fact. ",
            "selected_text": "a common approach in such replicated databases is to allow concurrent writes to create several conflicting versions of a value (also known as siblings), and to use application code or special data structures to resolve and merge these versions after the fact.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1148,
            "is_deleted": false,
            "representative_text": "Note that the additional table isn't used to store information about the booking--it's purely a collection of locks which is used to prevent bookings on the same room and time range from being modified concurrently. ",
            "selected_text": "Note that the additional table isn't used to store information about the booking--it's",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1149,
            "is_deleted": false,
            "representative_text": "The simplest way of avoiding concurrency problems is to remove the concurrency entirely: to execute only one transaction at a time, in serial order, on a single thread. By doing so, we completely sidestep the problem of detecting and preventing conflicts between transactions: the resulting isolation is by definition serializable. ",
            "selected_text": "to execute only one transaction at a time, in serial order, on a single thread. By doing so, we completely sidestep the problem of detecting and preventing conflicts between transactions: the resulting isolation is by definition serializable.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1150,
            "is_deleted": false,
            "representative_text": "Snapshot isolation is a boon for long-running, read-only queries such as backups and analytics. It is very hard to reason about the meaning of a query if the data on which it operates is changing at the same time as the query is executing. When a transaction can see a consistent snapshot of the database, frozen at a particular point in time, it is much easier to understand. ",
            "selected_text": "Snapshot isolation is a boon for long-running, read-only queries such as backups and analytics. It is very hard to reason about the meaning of a query if the data on which it operates is changing at the same time as the query is executing. When a transaction can see a consistent snapshot of the database, frozen at a particular point in time, it is much easier to understand.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1151,
            "is_deleted": false,
            "representative_text": "Atomic operations are usually implemented by taking an exclusive lock on the object when it is read so that no other transaction can read it until the update has been applied. ",
            "selected_text": "Atomic operations are usually implemented by taking an exclusive lock on the object when it is read so that no other transaction can read it until the update has been applied",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1167,
            "is_deleted": false,
            "representative_text": "The blocking of readers and writers is implemented by a having a lock on each object in the database. The lock can either be in shared mode or in exclusive mode. The lock is used as follows: ",
            "selected_text": "The blocking of readers and writers is implemented by a having a lock on each object in the database. The lock can either be in shared mode or in exclusive mode. The lock is used as follows:",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1169,
            "is_deleted": false,
            "representative_text": "It may take just one slow transaction, or one transaction that accesses a lot of data and acquires many locks, to cause the rest of the system to grind to a halt. This instability is problematic when robust operation is required. ",
            "selected_text": "It may take just one slow transaction, or one transaction that accesses a lot of data and acquires many locks, to cause the rest of the system to grind to a halt. This instability is problematic when robust operation is required",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1170,
            "is_deleted": false,
            "representative_text": "For this reason, systems with single-threaded serial transaction processing don't allow interactive multi-statement transactions. Instead, the application must submit the entire transaction code to the database ahead of time, as a stored procedure. ",
            "selected_text": "systems with single-threaded serial transaction processing don't allow interactive multi-statement transactions. Instead, the application must submit the entire transaction code to the database ahead of time, as a stored procedure",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1171,
            "is_deleted": false,
            "representative_text": "Since so many locks are in use, it can happen quite easily that transaction A is stuck waiting for transaction B to release its lock, and vice versa. This situation is called deadlock. The database automatically detects deadlocks between transactions and aborts one of them so that the others can make progress. The aborted transaction needs to be retried by the application. ",
            "selected_text": "Since so many locks are in use, it can happen quite easily that transaction A is stuck waiting for transaction B to release its lock, and vice versa. This situation is called deadlock. The database automatically detects deadlocks between transactions and aborts one of them so that the others can make progress. The aborted transaction needs to be retried by the application.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1175,
            "is_deleted": false,
            "representative_text": "Snapshot isolation has the mantra readers never block writers, and writers never block readers (see \"Implementing snapshot isolation\"), which captures this key difference between snapshot isolation and two-phase locking. ",
            "selected_text": "Snapshot isolation has the mantra readers never block writers, and writers never block readers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1177,
            "is_deleted": false,
            "representative_text": "This is where the name \"two-phase\" comes from: the first phase (while the transaction is executing) is when the locks are acquired, and the second phase (at the end of the transaction) is when all the locks are released. ",
            "selected_text": "This is where the name \"two-phase\" comes from: the first phase (while the transaction is executing) is when the locks are acquired, and the second phase (at the end of the transaction) is when all the locks are released.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1179,
            "is_deleted": false,
            "representative_text": " \"Phantoms causing write skew\" we discussed the problem of phantoms--that is, one transaction changing the results of another transaction's search query. ",
            "selected_text": "phantoms--that is, one transaction changing the results of another transaction's search query",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1180,
            "is_deleted": false,
            "representative_text": "Executing all transactions serially makes concurrency control much simpler, but limits the transaction throughput of the database to the speed of a single CPU core on a single machine. Read-only transactions may execute elsewhere, using snapshot isolation, but for applications with high write throughput, the single-threaded transaction processor can become a serious bottleneck. ",
            "selected_text": "Executing all transactions serially makes concurrency control much simpler, but limits the transaction throughput of the database to the speed of a single CPU core on a single machine. Read-only transactions may execute elsewhere, using snapshot isolation, but for applications with high write throughput, the single-threaded transaction processor can become a serious bottleneck",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1181,
            "is_deleted": false,
            "representative_text": "Several transactions are allowed to concurrently read the same object as long as nobody is writing to it. But as soon as anyone wants to write (modify or delete) an object, exclusive access is required: ",
            "selected_text": "Several transactions are allowed to concurrently read the same object as long as nobody is writing to it. But as soon as anyone wants to write (modify or delete) an object, exclusive access is required:",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1182,
            "is_deleted": false,
            "representative_text": "A new HTTP request starts a new transaction. ",
            "selected_text": "A new HTTP request starts a new transaction.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1183,
            "is_deleted": false,
            "representative_text": "it protects against all the race conditions discussed earlier, including lost updates and write skew. ",
            "selected_text": "it protects against all the race conditions discussed earlier, including lost updates and write skew.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1185,
            "is_deleted": false,
            "representative_text": "In 2PL, writers don't just block other writers; they also block readers and vice versa. ",
            "selected_text": "In 2PL, writers don't just block other writers; they also block readers and vice versa",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1186,
            "is_deleted": false,
            "representative_text": "1970s, is performance: transaction throughput and response times of queries are significantly worse under two-phase locking than under weak isolation. ",
            "selected_text": "transaction throughput and response times of queries are significantly worse under two-phase locking than under weak isolation.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1189,
            "is_deleted": false,
            "representative_text": "If one node fails, a common solution is to simply stop the entire cluster workload. After the faulty node is repaired, the computation is restarted from the last checkpoint [7, 8]. Thus, a supercomputer is more like a single-node computer than a distributed system: it deals with partial failure by letting it escalate into total failure--if any part of the system fails, just let everything crash (like a kernel panic on a single machine). ",
            "selected_text": "If one node fails, a common solution is to simply stop the entire cluster workload. After the faulty node is repaired, the computation is restarted from the last checkpoint [7, 8]. Thus, a supercomputer is more like a single-node computer than a distributed system",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1191,
            "is_deleted": false,
            "representative_text": "A long timeout means a long wait until a node is declared dead (and during this time, users may have to wait or see error messages). A short timeout detects faults faster, but carries a higher risk of incorrectly declaring a node dead when in fact it has only suffered a temporary slowdown (e.g., due to a load spike on the node or the network). ",
            "selected_text": "A long timeout means a long wait until a node is declared dead (and during this time, users may have to wait or see error messages). A short timeout detects faults faster, but carries a higher risk of incorrectly declaring a node dead when in fact it has only suffered a temporary slowdown",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1194,
            "is_deleted": false,
            "representative_text": "Serial execution is, in a sense, pessimistic to the extreme: it is essentially equivalent to each transaction having an exclusive lock on the entire database (or one partition of the database) for the duration of the transaction. We compensate for the pessimism by making each transaction very fast to execute, so it only needs to hold the \"lock\" for a short time. ",
            "selected_text": "Serial execution is, in a sense, pessimistic to the extreme: it is essentially equivalent to each transaction having an exclusive lock on the entire database (or one partition of the database) for the duration of the transaction. We compensate for the pessimism by making each transaction very fast to execute, so it only needs to hold the \"lock\" for a short time.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1195,
            "is_deleted": false,
            "representative_text": "If the database keeps track of each transaction's activity in great detail, it can be precise about which transactions need to abort, but the bookkeeping overhead can become significant. Less detailed tracking is faster, but may lead to more transactions being aborted than strictly necessary. ",
            "selected_text": "If the database keeps track of each transaction's activity in great detail, it can be precise about which transactions need to abort, but the bookkeeping overhead can become significant. Less detailed tracking is faster, but may lead to more transactions being aborted than strictly necessary.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1197,
            "is_deleted": false,
            "representative_text": "For that reason, most databases with 2PL actually implement index-range locking (also known as next-key locking), which is a simplified approximation of predicate locking [41, 50]. ",
            "selected_text": "most databases with 2PL actually implement index-range locking (also known as next-key locking), which is a simplified approximation of predicate locking",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1198,
            "is_deleted": false,
            "representative_text": "The fault handling must be part of the software design, and you (as operator of the software) need to know what behavior to expect from the software in the case of a fault. ",
            "selected_text": "The fault handling must be part of the software design, and you (as operator of the software) need to know what behavior to expect from the software in the case of a fault.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1199,
            "is_deleted": false,
            "representative_text": "UDP is a good choice in situations where delayed data is worthless. ",
            "selected_text": "UDP is a good choice in situations where delayed data is worthless",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1200,
            "is_deleted": false,
            "representative_text": "However, if there is enough spare capacity, and if contention between transactions is not too high, optimistic concurrency control techniques tend to perform better than pessimistic ones. ",
            "selected_text": "there is enough spare capacity, and if contention between transactions is not too high, optimistic concurrency control techniques tend to perform better than pessimistic ones",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1201,
            "is_deleted": false,
            "representative_text": "By avoiding unnecessary aborts, SSI preserves snapshot isolation's support for long-running reads from a consistent snapshot. ",
            "selected_text": "By avoiding unnecessary aborts, SSI preserves snapshot isolation's support for long-running reads from a consistent snapshot.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1202,
            "is_deleted": false,
            "representative_text": "When one part of the network is cut off from the rest due to a network fault, that is sometimes called a network partition or netsplit. ",
            "selected_text": "When one part of the network is cut off from the rest due to a network fault, that is sometimes called a network partition or netsplit",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1203,
            "is_deleted": false,
            "representative_text": "Shared-nothing is not the only way of building systems, but it has become the dominant approach for building internet services, for several reasons: it's comparatively cheap because it requires no special hardware, it can make use of commoditized cloud computing services, and it can achieve high reliability through redundancy across multiple geographically distributed datacenters. ",
            "selected_text": "Shared-nothing is not the only way of building systems, but it has become the dominant approach for building internet services, for several reasons: it's comparatively cheap because it requires no special hardware, it can make use of commoditized cloud computing services, and it can achieve high reliability through redundancy across multiple geographically distributed datacenters",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1208,
            "is_deleted": false,
            "representative_text": "Why not abort transaction 43 immediately when the stale read is detected? Well, if transaction 43 was a read-only transaction, it wouldn't need to be aborted, because there is no risk of write skew. ",
            "selected_text": "Why not abort transaction 43 immediately when the stale read is detected? Well, if transaction 43 was a read-only transaction, it wouldn't need to be aborted, because there is no risk of write skew",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1209,
            "is_deleted": false,
            "representative_text": "This chapter has painted a bleak picture of concurrency control in databases. On the one hand, we have implementations of serializability that don't perform well (two-phase locking) or don't scale well (serial execution). On the other hand, we have weak isolation levels that have good performance, but are prone to various race conditions (lost updates, write skew, phantoms, etc.). ",
            "selected_text": " On the one hand, we have implementations of serializability that don't perform well (two-phase locking) or don't scale well (serial execution). On the other hand, we have weak isolation levels that have good performance, but are prone to various race conditions (lost updates, write skew, phantoms, etc.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1212,
            "is_deleted": false,
            "representative_text": "When a transaction wants to commit, the database checks whether anything bad happened (i.e., whether isolation was violated); if so, the transaction is aborted and has to be retried. Only transactions that executed serializably are allowed to commit. ",
            "selected_text": "When a transaction wants to commit, the database checks whether anything bad happened (i.e., whether isolation was violated); if so, the transaction is aborted and has to be retried. Only transactions that executed serializably are allowed to commit.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1213,
            "is_deleted": false,
            "representative_text": "In particular, read-only queries can run on a consistent snapshot without requiring any locks, which is very appealing for read-heavy workloads. ",
            "selected_text": "read-only queries can run on a consistent snapshot without requiring any locks, which is very appealing for read-heavy workloads.",
            "color": "yellow",
            "note": "Readers don't block writers",
            "chapter": null
        },
        {
            "id": 1217,
            "is_deleted": false,
            "representative_text": "(As discussed in \"Reliability\", there is no such thing as perfect reliability, so we'll need to understand the limits of what we can realistically promise.) ",
            "selected_text": "there is no such thing as perfect reliability",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1218,
            "is_deleted": false,
            "representative_text": "Dirty reads One client reads another client's writes before they have been committed. The read committed isolation level and stronger levels prevent dirty reads. Dirty writes One client overwrites data that another client has written, but not yet committed. Almost all transaction implementations prevent dirty writes. Read skew (nonrepeatable reads) A client sees different parts of the database at different points in time. This issue is most commonly prevented with snapshot isolation, which allows a transaction to read from a consistent snapshot at one point in time. It is usually implemented with multi-version concurrency control (MVCC). Lost updates Two clients concurrently perform a read-modify-write cycle. One overwrites the other's write without incorporating its changes, so data is lost. Some implementations of snapshot isolation prevent this anomaly automatically, while others require a manual lock (SELECT FOR UPDATE). Write skew A transaction reads something, makes a decision based on the value it saw, and writes the decision to the database. However, by the time the write is made, the premise of the decision is no longer true. Only serializable isolation prevents this anomaly. Phantom reads A transaction reads objects that match some search condition. Another client makes a write that affects the results of that search. Snapshot isolation prevents straightforward phantom reads, but phantoms in the context of write skew require special treatment, such as index-range locks. Weak isolation levels protect against some of those anomalies but leave you, the application developer, to handle others manually (e.g., using explicit locking). Only serializable isolation protects against all of these issues. We discussed three different approaches to implementing serializable transactions: Literally executing transactions in a serial order If you can make each transaction very fast to execute, and the transaction throughput is low enough to process on a single CPU core, this is a simple and effective option. Two-phase locking For decades this has been the standard way of implementing serializability, but many applications avoid using it because of its performance characteristics. Serializable snapshot isolation (SSI) A fairly new algorithm that avoids most of the downsides of the previous approaches. It uses an optimistic approach, allowing transactions to proceed without blocking. When a transaction wants to commit, it is checked, and it is aborted if the execution was not serializable. ",
            "selected_text": "Dirty reads One client reads another client's writes before they have been committed. The read committed isolation level and stronger levels prevent dirty reads. Dirty writes One client overwrites data that another client has written, but not yet committed. Almost all transaction implementations prevent dirty writes. Read skew (nonrepeatable reads) A client sees different parts of the database at different points in time. This issue is most commonly prevented with snapshot isolation, which allows a transaction to read from a consistent snapshot at one point in time. It is usually implemented with multi-version concurrency control (MVCC). Lost updates Two clients concurrently perform a read-modify-write cycle. One overwrites the other's write without incorporating its changes, so data is lost. Some implementations of snapshot isolation prevent this anomaly automatically, while others require a manual lock (SELECT FOR UPDATE). Write skew A transaction reads something, makes a decision based on the value it saw, and writes the decision to the database. However, by the time the write is made, the premise of the decision is no longer true. Only serializable isolation prevents this anomaly. Phantom reads A transaction reads objects that match some search condition. Another client makes a write that affects the results of that search. Snapshot isolation prevents straightforward phantom reads, but phantoms in the context of write skew require special treatment, such as index-range locks. Weak isolation levels protect against some of those anomalies but leave you, the application developer, to handle others manually (e.g., using explicit locking). Only serializable isolation protects against all of these issues. We discussed three different approaches to implementing serializable transactions: Literally executing transactions in a serial order If you can make each transaction very fast to execute, and the transaction throughput is low enough to process on a single CPU core, this is a simple and effective option. Two-phase locking For decades this has been the standard way of implementing serializability, but many applications avoid using it because of its performance characteristics. Serializable snapshot isolation (SSI) A fairly new algorithm that avoids most of the downsides of the previous approaches. It uses an optimistic approach, allowing transactions to proceed without blocking. When a transaction wants to commit, it is checked, and it is aborted if the execution was not serializable.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1222,
            "is_deleted": false,
            "representative_text": "By contrast, serializable snapshot isolation is an optimistic concurrency control technique. Optimistic in this context means that instead of blocking if something potentially dangerous happens, transactions continue anyway, in the hope that everything will turn out all right. ",
            "selected_text": "By contrast, serializable snapshot isolation is an optimistic concurrency control technique. Optimistic in this context means that instead of blocking if something potentially dangerous happens, transactions continue anyway, in the hope that everything will turn out all right",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1224,
            "is_deleted": false,
            "representative_text": "The usual way of handling this issue is a timeout: after some time you give up waiting and assume that the response is not going to arrive. ",
            "selected_text": "The usual way of handling this issue is a timeout: after some time you give up waiting and assume that the response is not going to arrive",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1225,
            "is_deleted": false,
            "representative_text": "principle that if anything might possibly go wrong (as indicated by a lock held by another transaction), it's better to wait until the situation is safe again before doing anything. It is like mutual exclusion, which is used to protect data structures in multi-threaded programming. ",
            "selected_text": "if anything might possibly go wrong (as indicated by a lock held by another transaction), it's better to wait until the situation is safe again before doing anything. It is like mutual exclusion, which is used to protect data structures in multi-threaded programming",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1226,
            "is_deleted": false,
            "representative_text": "This nondeterminism and possibility of partial failures is what makes distributed systems hard to work with [5]. ",
            "selected_text": "This nondeterminism and possibility of partial failures is what makes distributed systems hard to work with",
            "color": "yellow",
            "note": "A single system either fails fully or succeeds completely. But at disturbed system can fail partially",
            "chapter": null
        },
        {
            "id": 1229,
            "is_deleted": false,
            "representative_text": "snapshot isolation, SSI adds an algorithm for detecting serialization conflicts among writes and determining which transactions to abort. ",
            "selected_text": "SSI adds an algorithm for detecting serialization conflicts among writes and determining which transactions to abort",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1231,
            "is_deleted": false,
            "representative_text": "interruption in the sound) and move on in the stream. The retry happens at the human layer instead. (\"Could you repeat that please? The sound just cut out for a moment.\") ",
            "selected_text": " The retry happens at the human layer instead. (\"Could you repeat that please? The sound just cut out for a moment.\")",
            "color": "yellow",
            "note": "lol",
            "chapter": null
        },
        {
            "id": 1244,
            "is_deleted": false,
            "representative_text": "it is in, because problems in the network cannot reliably be distinguished from problems at a node. ",
            "selected_text": "problems in the network cannot reliably be distinguished from problems at a node.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1246,
            "is_deleted": false,
            "representative_text": "The difference between the two values tells you how much time elapsed between the two checks. ",
            "selected_text": "The difference between the two values tells you how much time elapsed between the two checks",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1250,
            "is_deleted": false,
            "representative_text": "(e.g., due to a network interruption or GC pause), it may have been demoted and another leader may have already been elected. ",
            "selected_text": "due to a network interruption or GC pause",
            "color": "yellow",
            "note": "Reasons a node could be declared dead",
            "chapter": null
        },
        {
            "id": 1252,
            "is_deleted": false,
            "representative_text": "Checking a token on the server side may seem like a downside, but it is arguably a good thing: it is unwise for a service to assume that its clients will always be well behaved, because the clients are often run by people whose priorities are very different from the priorities of the people running the service [76]. ",
            "selected_text": "it is unwise for a service to assume that its clients will always be well behaved, because the clients are often run by people whose priorities are very different from the priorities of the people running the service",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1254,
            "is_deleted": false,
            "representative_text": "epoch: midnight UTC on January 1, 1970, according to the Gregorian calendar, not counting leap seconds. ",
            "selected_text": "epoch: midnight UTC on January 1, 1970",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1255,
            "is_deleted": false,
            "representative_text": "That includes decisions about declaring nodes dead. If a quorum of nodes declares another node dead, then it must be considered dead, even if that node still very much feels alive. The individual node must abide by the quorum decision and step down. ",
            "selected_text": "That includes decisions about declaring nodes dead. If a quorum of nodes declares another node dead, then it must be considered dead, even if that node still very much feels alive. The individual node must abide by the quorum decision and step down",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1259,
            "is_deleted": false,
            "representative_text": "A system is Byzantine fault-tolerant if it continues to operate correctly even if some of the nodes are malfunctioning and not obeying the protocol, or if malicious attackers are interfering with the network. ",
            "selected_text": "A system is Byzantine fault-tolerant if it continues to operate correctly even if some of the nodes are malfunctioning and not obeying the protocol, or if malicious attackers are interfering with the network",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1262,
            "is_deleted": false,
            "representative_text": "However, with liveness properties we are allowed to make caveats: for example, we could say that a request needs to receive a response only if a majority of nodes have not crashed, and only if the network eventually recovers from an outage. ",
            "selected_text": "However, with liveness properties we are allowed to make caveats: for example, we could say that a request needs to receive a response only if a majority of nodes have not crashed, and only if the network eventually recovers from an outage",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1267,
            "is_deleted": false,
            "representative_text": "requires that eventually the system returns to a synchronous state--that is, any period of network interruption lasts only for a finite duration and is then repaired. ",
            "selected_text": "that is, any period of network interruption lasts only for a finite duration and is then repaired",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1268,
            "is_deleted": false,
            "representative_text": "This is a realistic model of many systems: most of the time, networks and processes are quite well behaved--otherwise we would never be able to get anything done--but we have to reckon with the fact that any timing assumptions may be shattered occasionally. ",
            "selected_text": "This is a realistic model of many systems: most of the time, networks and processes are quite well behaved--otherwise we would never be able to get anything done--but we have to reckon with the fact that any timing assumptions may be shattered occasionally",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1270,
            "is_deleted": false,
            "representative_text": "For modeling real systems, the partially synchronous model with crash-recovery faults is generally the most useful model. ",
            "selected_text": "For modeling real systems, the partially synchronous model with crash-recovery faults is generally the most useful model",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1275,
            "is_deleted": false,
            "representative_text": "(And yes, you guessed it--eventual consistency is a liveness property [89].) ",
            "selected_text": "eventual consistency is a liveness property",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1278,
            "is_deleted": false,
            "representative_text": "Safety is often informally defined as nothing bad happens, and liveness as something good eventually happens. ",
            "selected_text": "Safety is often informally defined as nothing bad happens, and liveness as something good eventually happens",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1279,
            "is_deleted": false,
            "representative_text": "That is, even if all nodes crash, or the entire network fails, the algorithm must nevertheless ensure that it does not return a wrong result (i.e., that the safety properties remain satisfied). ",
            "selected_text": "That is, even if all nodes crash, or the entire network fails, the algorithm must nevertheless ensure that it does not return a wrong result (i.e., that the safety properties remain satisfied",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1285,
            "is_deleted": false,
            "representative_text": "They don't come for free: systems with stronger guarantees may have worse performance or be less fault-tolerant than systems with weaker guarantees. ",
            "selected_text": "systems with stronger guarantees may have worse performance or be less fault-tolerant than systems with weaker guarantees",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1286,
            "is_deleted": false,
            "representative_text": "But while there is some overlap, they are mostly independent concerns: transaction isolation is primarily about avoiding race conditions due to concurrently executing transactions, whereas distributed consistency is mostly about coordinating the state of replicas in the face of delays and faults. ",
            "selected_text": "transaction isolation is primarily about avoiding race conditions due to concurrently executing transactions, whereas distributed consistency is mostly about coordinating the state of replicas in the face of delays and faults.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1288,
            "is_deleted": false,
            "representative_text": "The simplest way of handling such faults is to simply let the entire service fail, and show the user an error message. ",
            "selected_text": "The simplest way of handling such faults is to simply let the entire service fail, and show the user an error message",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1289,
            "is_deleted": false,
            "representative_text": "But the basic idea is to make a system appear as if there were only one copy of the data, and all operations on it are atomic. ",
            "selected_text": "the basic idea is to make a system appear as if there were only one copy of the data, and all operations on it are atomic",
            "color": "yellow",
            "note": "Liberalizability",
            "chapter": null
        },
        {
            "id": 1290,
            "is_deleted": false,
            "representative_text": "This is because the customers with the slowest requests are often those who have the most data on their accounts because they have made many purchases--that is, they're the most valuable customers [19]. It's important to keep those customers happy by ensuring the website is fast for them: Amazon has also observed that a 100 ms increase in response time reduces sales by 1% [20], and others report that a 1-second slowdown reduces a customer satisfaction metric by 16% [21, 22]. ",
            "selected_text": "This is because the customers with the slowest requests are often those who have the most data on their accounts because they have made many purchases--that is, they're the most valuable customers [19]. It's important to keep those customers happy by ensuring the website is fast for them:",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1291,
            "is_deleted": false,
            "representative_text": "At times when the network is working correctly, a system can provide both consistency (linearizability) and total availability. When a network fault occurs, you have to choose between either linearizability or total availability. ",
            "selected_text": "At times when the network is working correctly, a system can provide both consistency (linearizability) and total availability. When a network fault occurs, you have to choose between either linearizability or total availability",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1292,
            "is_deleted": false,
            "representative_text": "In this case, when the resizer fetches the image (step 5), it might see an old version of the image, or nothing at all. ",
            "selected_text": "In this case, when the resizer fetches the image (step 5), it might see an old version of the image, or nothing at all",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1293,
            "is_deleted": false,
            "representative_text": "This requirement ensures the recency guarantee we discussed earlier: once a new value has been written or read, all subsequent reads see the value that was written, until it is overwritten again. ",
            "selected_text": "This requirement ensures the recency guarantee we discussed earlier: once a new value has been written or read, all subsequent reads see the value that was written, until it is overwritten again",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1294,
            "is_deleted": false,
            "representative_text": "If your application requires linearizability, and some replicas are disconnected from the other replicas due to a network problem, then some replicas cannot process requests while they are disconnected: they must either wait until the network problem is fixed, or return an error (either way, they become unavailable). If your application does not require linearizability, then it can be written in a way that each replica can process requests independently, even if it is disconnected from other replicas (e.g., multi-leader). In this case, the application can remain available in the face of a network problem, but its behavior is not linearizable. ",
            "selected_text": "If your application requires linearizability, and some replicas are disconnected from the other replicas due to a network problem, then some replicas cannot process requests while they are disconnected: they must either wait until the network problem is fixed, or return an error (either way, they become unavailable). If your application does not require linearizability, then it can be written in a way that each replica can process requests independently, even if it is disconnected from other replicas (e.g., multi-leader). In this case, the application can remain available in the face of a network problem, but its behavior is not linearizable.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1295,
            "is_deleted": false,
            "representative_text": "either Consistent or Available when Partitioned [39]. ",
            "selected_text": "either Consistent or Available when Partitioned",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1298,
            "is_deleted": false,
            "representative_text": "Linearizability is a recency guarantee on reads and writes of a register (an individual object). It doesn't group operations together into transactions, so it does not prevent problems such as write skew (see \"Write Skew and Phantoms\"), unless you take additional measures such as materializing conflicts (see \"Materializing conflicts\"). ",
            "selected_text": "Linearizability is a recency guarantee on reads and writes of a register (an individual object). It doesn't group operations together into transactions, so it does not prevent problems such as write skew",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1299,
            "is_deleted": false,
            "representative_text": "The requirement of linearizability is that the lines joining up the operation markers always move forward in time (from left to right), never backward. ",
            "selected_text": "The requirement of linearizability is that the lines joining up the operation markers always move forward in time (from left to right), never backward",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1301,
            "is_deleted": false,
            "representative_text": "If the network between datacenters is interrupted in a single-leader setup, clients connected to follower datacenters cannot contact the leader, so they cannot make any writes to the database, nor any linearizable reads. They can still make reads from the follower, but they might be stale (nonlinearizable). ",
            "selected_text": "If the network between datacenters is interrupted in a single-leader setup, clients connected to follower datacenters cannot contact the leader, so they cannot make any writes to the database, nor any linearizable reads. They can still make reads from the follower, but they might be stale (nonlinearizable)",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1302,
            "is_deleted": false,
            "representative_text": "These constraints all require there to be a single up-to-date value (the account balance, the stock level, the seat occupancy) that all nodes agree on. ",
            "selected_text": "These constraints all require there to be a single up-to-date value (the account balance, the stock level, the seat occupancy) that all nodes agree on.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1303,
            "is_deleted": false,
            "representative_text": "error), you need linearizability. ",
            "selected_text": "you need linearizability.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1304,
            "is_deleted": false,
            "representative_text": "Thus, if one client's read returns the new value 1, all subsequent reads must also return the new value, even if the write operation has not yet completed. ",
            "selected_text": "Thus, if one client's read returns the new value 1, all subsequent reads must also return the new value, even if the write operation has not yet completed.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1305,
            "is_deleted": false,
            "representative_text": "Systems with multi-leader replication are generally not linearizable, because they concurrently process writes on multiple nodes and asynchronously replicate them to other nodes. ",
            "selected_text": "Systems with multi-leader replication are generally not linearizable, because they concurrently process writes on multiple nodes and asynchronously replicate them to other nodes",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1307,
            "is_deleted": false,
            "representative_text": "Since linearizability essentially means \"behave as though there is only a single copy of the data, and all operations on it are atomic,\" the simplest answer would be to really only use a single copy of the data. ",
            "selected_text": "linearizability essentially means \"behave as though there is only a single copy of the data, and all operations on it are atomic",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1309,
            "is_deleted": false,
            "representative_text": "Serializability is an isolation property of transactions, where every transaction may read and write multiple objects (rows, documents, records)--see \"Single-Object and Multi-Object Operations\". It guarantees that transactions behave the same as if they had executed in some serial order (each transaction running to completion before the next transaction starts). ",
            "selected_text": "Serializability is an isolation property of transactions, where every transaction may read and write multiple objects (rows, documents, records)--see \"Single-Object and Multi-Object Operations\". It guarantees that transactions behave the same as if they had executed in some serial order (each transaction running to completion before the next transaction starts)",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1310,
            "is_deleted": false,
            "representative_text": "One way of electing a leader is to use a lock: every node that starts up tries to acquire the lock, and the one that succeeds becomes the leader [14]. No matter how this lock is implemented, it must be linearizable: all nodes must agree which node owns the lock; otherwise it is useless. ",
            "selected_text": "One way of electing a leader is to use a lock: every node that starts up tries to acquire the lock, and the one that succeeds becomes the leader [14]. No matter how this lock is implemented, it must be linearizable: all nodes must agree which node owns the lock; otherwise it is useless.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1311,
            "is_deleted": false,
            "representative_text": "If you want to enforce this constraint as the data is written (such that if two people try to concurrently create a user or a file with the same name, one of them will be returned an error), you need linearizability. ",
            "selected_text": "If you want to enforce this constraint as the data is written",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1312,
            "is_deleted": false,
            "representative_text": "images in the file storage become permanently inconsistent. ",
            "selected_text": "storage become permanently inconsistent",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1315,
            "is_deleted": false,
            "representative_text": "It is possible (though computationally expensive) to test whether a system's behavior is linearizable by recording the timings of all requests and responses, and checking whether they can be arranged into a valid sequential order [11]. ",
            "selected_text": "It is possible (though computationally expensive) to test whether a system's behavior is linearizable by recording the timings of all requests and responses, and checking whether they can be arranged into a valid sequential order [11].",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1316,
            "is_deleted": false,
            "representative_text": "Thus, applications that don't require linearizability can be more tolerant of network problems. ",
            "selected_text": "Thus, applications that don't require linearizability can be more tolerant of network problems",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1317,
            "is_deleted": false,
            "representative_text": "Even though crashes, race conditions, and disk failures do occur, the transaction abstraction hides those problems so that the application doesn't need to worry about them. ",
            "selected_text": "Even though crashes, race conditions, and disk failures do occur, the transaction abstraction hides those problems so that the application doesn't need to worry about them.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1352,
            "is_deleted": false,
            "representative_text": "Without hearing from the coordinator, the participant has no way of knowing whether to commit or abort. ",
            "selected_text": "Without hearing from the coordinator, the participant has no way of knowing whether to commit or abort",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1358,
            "is_deleted": false,
            "representative_text": "Atomicity prevents failed transactions from littering the database with half-finished results and half-updated state. ",
            "selected_text": "Atomicity prevents failed transactions from littering the database with half-finished results and half-updated state",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1360,
            "is_deleted": false,
            "representative_text": "Each secondary index is a separate data structure from the primary data--thus, if you modify some data, the corresponding change needs to also be made in the secondary index. Atomicity ensures that the secondary index stays consistent with the primary data (if the index became inconsistent with the primary data, it would not be very useful). ",
            "selected_text": "Each secondary index is a separate data structure from the primary data--thus, if you modify some data, the corresponding change needs to also be made in the secondary index. Atomicity ensures that the secondary index stays consistent with the primary data",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1363,
            "is_deleted": false,
            "representative_text": "If we want to maintain transaction atomicity (in the sense of ACID; see \"Atomicity\"), we have to get all nodes to agree on the outcome of the transaction: either they all abort/roll back (if anything goes wrong) or they all commit (if nothing goes wrong). ",
            "selected_text": "If we want to maintain transaction atomicity (in the sense of ACID; see \"Atomicity\"), we have to get all nodes to agree on the outcome of the transaction: either they all abort/roll back (if anything goes wrong) or they all commit (if nothing goes wrong)",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1364,
            "is_deleted": false,
            "representative_text": "In a database with single-leader replication, all nodes need to agree on which node is the leader. ",
            "selected_text": "In a database with single-leader replication, all nodes need to agree on which node is the leader",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1365,
            "is_deleted": false,
            "representative_text": "This is why the coordinator must write its commit or abort decision to a transaction log on disk before sending commit or abort requests to participants: when the coordinator recovers, it determines the status of all in-doubt transactions by reading its transaction log. ",
            "selected_text": "This is why the coordinator must write its commit or abort decision to a transaction log on disk before sending commit or abort requests to participants: when the coordinator recovers, it determines the status of all in-doubt transactions by reading its transaction log",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1367,
            "is_deleted": false,
            "representative_text": "In this case, consensus is important to avoid a bad failover, resulting in a split brain situation in which two nodes both believe themselves to be the leader (see \"Handling Node Outages\"). ",
            "selected_text": "In this case, consensus is important to avoid a bad failover, resulting in a split brain situation",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1452,
            "is_deleted": false,
            "representative_text": "If a participant has crashed in the meantime, the transaction will be committed when it recovers--since the participant voted \"yes,\" it cannot refuse to commit when it recovers. ",
            "selected_text": "If a participant has crashed in the meantime, the transaction will be committed when it recovers--since the participant voted \"yes,\" it cannot refuse to commit when it recovers",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1453,
            "is_deleted": false,
            "representative_text": "The reason for this rule is that once data has been committed, it becomes visible to other transactions, and thus other clients may start relying on that data; this principle forms the basis of read committed isolation, discussed in \"Read Committed\". ",
            "selected_text": "The reason for this rule is that once data has been committed, it becomes visible to other transactions, and thus other clients may start relying on that data; this principle forms the basis of read committed isolation",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1454,
            "is_deleted": false,
            "representative_text": "If all participants reply \"yes,\" indicating they are ready to commit, then the coordinator sends out a commit request in phase 2, and the commit actually takes place. ",
            "selected_text": "If all participants reply \"yes,\" indicating they are ready to commit, then the coordinator sends out a commit request in phase 2, and the commit actually takes place.",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1455,
            "is_deleted": false,
            "representative_text": "ready to commit, the coordinator begins phase 1: it sends a prepare request to each of the nodes, asking them whether they are able to commit. The coordinator then tracks the responses from the participants: ",
            "selected_text": "the coordinator begins phase 1: it sends a prepare request to each of the nodes, asking them whether they are able to commit. The coordinator then tracks the responses from the participants:",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1457,
            "is_deleted": false,
            "representative_text": "And once a transaction has been committed on one node, it cannot be retracted again if it later turns out that it was aborted on another node. ",
            "selected_text": "And once a transaction has been committed on one node, it cannot be retracted again if it later turns out that it was aborted on another node",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1460,
            "is_deleted": false,
            "representative_text": "If any of the participants replies \"no,\" the coordinator sends an abort request to all nodes in phase 2. ",
            "selected_text": "If any of the participants replies \"no,\" the coordinator sends an abort request to all nodes in phase 2",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1462,
            "is_deleted": false,
            "representative_text": "2PC provides atomic commit in a distributed database, whereas 2PL provides serializable isolation. ",
            "selected_text": "2PC provides atomic commit in a distributed database, whereas 2PL provides serializable isolation",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1464,
            "is_deleted": false,
            "representative_text": "When a participant receives the prepare request, it makes sure that it can definitely commit the transaction under all circumstances. ",
            "selected_text": "When a participant receives the prepare request, it makes sure that it can definitely commit the transaction under all circumstances",
            "color": "yellow",
            "note": null,
            "chapter": null
        },
        {
            "id": 1465,
            "is_deleted": false,
            "representative_text": "Two-phase commit is an algorithm for achieving atomic transaction commit across multiple nodes--i.e., to ensure that either all nodes commit or all nodes abort. ",
            "selected_text": "Two-phase commit is an algorithm for achieving atomic transaction commit across multiple nodes--i.e., to ensure that either all nodes commit or all nodes abort.",
            "color": "yellow",
            "note": null,
            "chapter": null
        }
    ]
}